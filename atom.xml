<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="https://www.w3.org/2005/Atom">
  <title>jthu的博客</title>
  
  <subtitle>后端技术</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://hicker000.github.io/"/>
  <updated>2020-02-25T06:40:18.109Z</updated>
  <id>https://hicker000.github.io/</id>
  
  <author>
    <name>jthu</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>a</title>
    <link href="https://hicker000.github.io/2020/02/25/a/"/>
    <id>https://hicker000.github.io/2020/02/25/a/</id>
    <published>2020-02-25T06:17:03.000Z</published>
    <updated>2020-02-25T06:40:18.109Z</updated>
    
    <content type="html"><![CDATA[<img src="/2020/02/25/a/pasted-0.png">]]></content>
    
    <summary type="html">
    
      
      
        &lt;img src=&quot;/2020/02/25/a/pasted-0.png&quot;&gt;


      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>什么是消息中间件？</title>
    <link href="https://hicker000.github.io/2020/02/25/%E4%BB%80%E4%B9%88%E6%98%AF%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%EF%BC%9F/"/>
    <id>https://hicker000.github.io/2020/02/25/%E4%BB%80%E4%B9%88%E6%98%AF%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%EF%BC%9F/</id>
    <published>2020-02-25T01:49:00.000Z</published>
    <updated>2020-02-25T06:05:39.960Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是消息中间件？"><a href="#什么是消息中间件？" class="headerlink" title="什么是消息中间件？"></a>什么是消息中间件？</h1><p>[toc]</p><h2 id="消息中间件-MQ-的定义"><a href="#消息中间件-MQ-的定义" class="headerlink" title="消息中间件(MQ)的定义"></a>消息中间件(MQ)的定义</h2><p>其实并没有标准定义。一般认为，消息中间件属于分布式系统中一个子系统，关注于数据的发送和接收，利用高效可靠的异步消息传递机制对分布式系统中的其余各个子系统进行集成。</p><p><img src="/2020/02/25/%E4%BB%80%E4%B9%88%E6%98%AF%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%EF%BC%9F/E:images%5Cimage-20200225140502618-1582610711570.png" alt="image-20200225140502618"></p><h2 id="为什么要用消息中间件？"><a href="#为什么要用消息中间件？" class="headerlink" title="为什么要用消息中间件？"></a>为什么要用消息中间件？</h2><p>假设一个电商交易的场景，用户下单之后调用库存系统减库存，然后需要调用物流系统进行发货，如果交易、库存、物流是属于一个系统的，那么就是接口调用。但是随着系统的发展，各个模块越来越庞大、业务逻辑越来越复杂，必然是要做服务化和业务拆分的。这个时候就需要考虑这些系统之间如何交互，第一反应就是RPC（Remote<br>Procedure<br>Call）。系统继续发展，可能一笔交易后续需要调用几十个接口来执行业务，比如还有风控系统、短信服务等等。这个时候就需要消息中间件登场来解决问题了。</p><p>所以消息中间件主要解决分布式系统之间消息的传递，同时为分布式系统中其他子系统提供了伸缩性和扩展性。为系统带来了：</p><ul><li><strong>低耦合</strong>，不管是程序还是模块之间，使用消息中间件进行间接通信。</li><li><strong>异步通信能力</strong>，使得子系统之间得以充分执行自己的逻辑而无需等待。</li><li><strong>缓冲能力</strong>，消息中间件像是一个巨大的蓄水池，将高峰期大量的请求存储下来慢慢交给后台进行处理，对于秒杀业务来说尤为重要。</li></ul><p><strong>名称解释</strong>：</p><ul><li><strong>伸缩性:</strong>，是指通过不断向集群中加入服务器的手段来缓解不断上升的用户并发访问压力和不断增长的数据存储需求。就像弹簧一样挂东西一样，用户多，伸一点，用户少，浅一点，啊，不对，缩一点。是伸缩，不是深浅。衡量架构是否高伸缩性的主要标准就是是否可用多台服务器构建集群，是否容易向集群中添加新的服务器。加入新的服务器后是否可以提供和原来服务器无差别的服务。集群中可容纳的总的服务器数量是否有限制。*</li><li><strong>扩展性:</strong>，主要标准就是在网站增加新的业务产品时，是否可以实现对现有产品透明无影响，不需要任何改动或者很少改动既有业务功能就可以上线新产品。比如用户购买电影票的应用，现在我们要增加一个功能，用户买了铁血战士的票后，随机抽取用户送异形的限量周边。怎么做到不改动用户购票功能的基础上增加这个功能。熟悉设计模式的同学，应该很眼熟，这是设计模式中的开闭原则（对扩展开放，对修改关闭）在架构层面的一个原则。*</li></ul><h2 id="和RPC有何区别？"><a href="#和RPC有何区别？" class="headerlink" title="和RPC有何区别？"></a>和RPC有何区别？</h2><p>RPC和消息中间件的场景的差异很大程度上在于就是“依赖性”和“同步性”。</p><ul><li>比如短信通知服务并不是事交易环节必须的，并不影响下单流程，不是强依赖，所以交易系统不应该依赖短信服务。比如一些数据分析程序可能需要在拿到一天的总销售量，这个就只需要销售中心提供接口在需要时调用即可。</li><li>消息中间件出现以后对于交易场景可能是调用库存中心等强依赖系统执行业务，之后发布一条消息（这条消息存储于消息中间件中）。像是短信通知服务、数据统计服务等等都是依赖于消息中间件去消费这条消息来完成自己的业务逻辑。</li><li><font color="red">RPC方式是典型的同步方式，让远程调用像本地调用。消息中间件方式属于异步方式。<strong>消息队列是系统级、模块级的通信。RPC是对象级、函数级通信。</strong></font></li></ul><p><strong>相同点:</strong> 都是分布式下面的通信方式。</p><h2 id="消息中间件有些什么使用场景？"><a href="#消息中间件有些什么使用场景？" class="headerlink" title="消息中间件有些什么使用场景？"></a>消息中间件有些什么使用场景？</h2><h3 id="异步处理"><a href="#异步处理" class="headerlink" title="异步处理"></a>异步处理</h3><p>场景说明：用户注册后，需要发注册邮件和注册短信。传统的做法有两种1.串行的方式；2.并行方式。</p><p>(1) <strong>串行方式</strong>：将注册信息写入数据库成功后，发送注册邮件，再发送注册短信。以上三个任务全部完成后，返回给客户端。</p><p><img src="/2020/02/25/%E4%BB%80%E4%B9%88%E6%98%AF%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%EF%BC%9F/D92FE5068C4E411A9740F27F480521DC" alt="image"></p><p>(2)<strong>并行方式</strong>：将注册信息写入数据库成功后，发送注册邮件的同时，发送注册短信。以上三个任务完成后，返回给客户端。与串行的差别是，并行的方式可以提高处理的时间。</p><p>假设三个业务节点每个使用50毫秒钟，不考虑网络等其他开销，则串行方式的时间是150毫秒，并行的时间可能是100毫秒。</p><p><img src="/2020/02/25/%E4%BB%80%E4%B9%88%E6%98%AF%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%EF%BC%9F/EF3E2B155D6B41E68552FC08563C66F7" alt="image"></p><p><strong>小结</strong>：如以上案例描述，传统的方式系统的性能（并发量，吞吐量，响应时间）会有瓶颈。如何解决这个问题呢？</p><p>引入消息队列，将不是必须的业务逻辑，异步处理。</p><p><img src="/2020/02/25/%E4%BB%80%E4%B9%88%E6%98%AF%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%EF%BC%9F/8AB460684DB3406DB06FD4E9E39F85D7" alt="image"></p><p>按照以上约定，用户的响应时间相当于是注册信息写入数据库的时间，也就是50毫秒。注册邮件，发送短信写入消息队列后，直接返回，因此写入消息队列的速度很快，基本可以忽略，因此用户的响应时间可能是50毫秒。因此架构改变后，系统的吞吐量提高到每秒20<br>QPS。比串行提高了3倍，比并行提高了两倍。</p><h3 id="应用解耦"><a href="#应用解耦" class="headerlink" title="应用解耦"></a>应用解耦</h3><p>场景说明：用户下单后，订单系统需要通知库存系统。传统的做法是，订单系统调用库存系统的接口。</p><p><strong>传统模式的缺点</strong>：</p><ul><li>1） 假如库存系统无法访问，则订单减库存将失败，从而导致订单失败；</li><li>2） 订单系统与库存系统耦合；</li></ul><p><img src="/2020/02/25/%E4%BB%80%E4%B9%88%E6%98%AF%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%EF%BC%9F/A7EFCEDEAFBE4B43BFA5F6C2A9FECBC0" alt="image"></p><p>如何解决以上问题呢？引入应用消息队列后的方案</p><p>订单系统：用户下单后，订单系统完成持久化处理，将消息写入消息队列，返回用户订单下单成功。</p><p>库存系统：订阅下单的消息，采用拉/推的方式，获取下单信息，库存系统根据下单信息，进行库存操作。</p><p><img src="/2020/02/25/%E4%BB%80%E4%B9%88%E6%98%AF%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%EF%BC%9F/69AD47A4A43E4EB69962FE709ED2DA80" alt="image"></p><p><strong>假如</strong>：在下单时库存系统不能正常使用。也不影响正常下单，因为下单后，订单系统写入消息队列就不再关心其他的后续操作了。实现订单系统与库存系统的应用解耦。</p><h3 id="流量削峰"><a href="#流量削峰" class="headerlink" title="流量削峰"></a>流量削峰</h3><p>流量削峰也是消息队列中的常用场景，一般在秒杀或团抢活动中使用广泛。</p><p><strong>应用场景</strong>：秒杀活动，一般会因为流量过大，导致流量暴增，应用挂掉。为解决这个问题，一般需要在应用前端加入消息队列：可以控制活动的人数；可以缓解短时间内高流量压垮应用。</p><p><img src="/2020/02/25/%E4%BB%80%E4%B9%88%E6%98%AF%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%EF%BC%9F/CA3E68D1A5FC40499746A88D55F16B63" alt="image"></p><p>用户的请求，服务器接收后，首先写入消息队列。假如消息队列长度超过最大数量，则直接抛弃用户请求或跳转到错误页面；秒杀业务根据消息队列中的请求信息，再做后续处理。</p><h3 id="日志处理"><a href="#日志处理" class="headerlink" title="日志处理"></a>日志处理</h3><p>日志处理是指将消息队列用在日志处理中，比如Kafka的应用，解决大量日志传输的问题。架构简化如下：</p><p><img src="/2020/02/25/%E4%BB%80%E4%B9%88%E6%98%AF%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%EF%BC%9F/5F7B30CA9DD7425DB3F3240C112ACB4A" alt="image"></p><p>日志采集客户端，负责日志数据采集，定时写入Kafka队列：Kafka消息队列，负责日志数据的接收，存储和转发；日志处理应用：订阅并消费kafka队列中的日志数据；</p><h3 id="消息通讯"><a href="#消息通讯" class="headerlink" title="消息通讯"></a>消息通讯</h3><p>消息通讯是指，消息队列一般都内置了高效的通信机制，因此也可以用在纯的消息通讯。比如实现点对点消息队列，或者聊天室等。</p><ul><li><strong>点对点通讯</strong>：客户端A和客户端B使用同一队列，进行消息通讯。</li><li><strong>聊天室通讯</strong>：客户端A，客户端B，客户端N订阅同一主题，进行消息发布和接收。实现类似聊天室效果。</li></ul><h2 id="消息中间件的编年史"><a href="#消息中间件的编年史" class="headerlink" title="消息中间件的编年史 "></a>消息中间件的编年史 </h2><p><img src="/2020/02/25/%E4%BB%80%E4%B9%88%E6%98%AF%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%EF%BC%9F/54FABC73987645D891DF50A715706457" alt="image"></p><p>卡夫卡与法国作家马塞尔·普鲁斯特，爱尔兰作家詹姆斯·乔伊斯并称为西方现代主义文学的先驱和大师。《变形记》是卡夫卡的短篇代表作，是卡夫卡的艺术成就中的一座高峰，被认为是20世纪最伟大的小说作品之一。</p><h2 id="常见的消息中间件比较"><a href="#常见的消息中间件比较" class="headerlink" title="常见的消息中间件比较 "></a>常见的消息中间件比较 </h2><p><img src="/2020/02/25/%E4%BB%80%E4%B9%88%E6%98%AF%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%EF%BC%9F/928587A370774B53B647863BB36F2695" alt="image"></p><p>如果一般的业务系统要引入MQ，怎么选型：</p><ul><li>用户访问量在ActiveMQ的可承受范围内，而且确实主要是基于解耦和异步来用的，可以考虑ActiveMQ，也比较贴近Java工程师的使用习惯。</li><li>RabbitMQ，但是确实erlang语言阻止了我们去深入研究和掌控，对公司而言，几乎处于不可控的状态，但是确实是开源的，有比较稳定的支持，活跃度也高。</li><li>对自己公司技术实力有绝对自信的，可以用RocketMQ 。</li><li>所以中小型公司，技术实力较为一般，技术挑战不是特别高，用ActiveMQ、RabbitMQ是不错的选择；大型公司，基础架构研发实力较强，用RocketMQ是很好的选择</li><li>如果是大数据领域的实时计算、日志采集等场景，用Kafka是业内标准的，绝对没问题，社区活跃度很高，几乎是全世界这个领域的事实性规范。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;什么是消息中间件？&quot;&gt;&lt;a href=&quot;#什么是消息中间件？&quot; class=&quot;headerlink&quot; title=&quot;什么是消息中间件？&quot;&gt;&lt;/a&gt;什么是消息中间件？&lt;/h1&gt;&lt;p&gt;[toc]&lt;/p&gt;
&lt;h2 id=&quot;消息中间件-MQ-的定义&quot;&gt;&lt;a href=&quot;#
      
    
    </summary>
    
    
      <category term="消息中间件" scheme="https://hicker000.github.io/categories/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
      <category term="中间件" scheme="https://hicker000.github.io/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>nginx基础</title>
    <link href="https://hicker000.github.io/2019/11/25/nginx%E5%9F%BA%E7%A1%80/"/>
    <id>https://hicker000.github.io/2019/11/25/nginx%E5%9F%BA%E7%A1%80/</id>
    <published>2019-11-25T09:00:50.000Z</published>
    <updated>2019-11-25T09:04:05.254Z</updated>
    
    <content type="html"><![CDATA[<h1 id="nginx基础"><a href="#nginx基础" class="headerlink" title="nginx基础"></a>nginx基础</h1><ul><li><a href="#1">一、Nginx简介</a></li><li><a href="#2">二，Nginx架构设计</a></li><li><a href="#3">三、nginx安装</a></li><li><a href="#4">四、文件结构以及模型概念</a></li><li><a href="#5">五、Nginx日志</a></li></ul><hr><h2 id="一，Nginx简介"><a href="#一，Nginx简介" class="headerlink" title="一，Nginx简介"></a><span id="1">一，Nginx简介</span></h2><p><strong>Apache</strong></p><p>Apache仍然是时长占用量最高的web服务器，据最新数据统计，市场占有率目前是50%左右。主要优势在于一个是比较早出现的一个Http静态资源服务器，同时又是开源的。所以在技术上的支持以及市面上的各种解决方案都比较成熟。Apache支持的模块非常丰富。</p><p><strong>Nginx</strong></p><p>Nginx是俄罗斯人编写的一款高性能的HTTP和反向代理服务器，在高连接并发的情况下，它能够支持高达50000个并发连接数的响应，但是内存、CPU等系统资源消耗却很低，运行很稳定。目前Nginx在国内很多大型企业都有应用，据最新统计，Nginx的市场占有率已经到33%左右了。而Apache的市场占有率虽然仍然是最高的，但是是呈下降趋势。而Nginx的势头很明显。选择Nginx的理由也很简单：第一，它可以支持5W高并发连接；第二，内存消耗少；第三，成本低，如果采用F5、NetScaler等硬件负载均衡设备的话，需要大几十万。而Nginx是开源的，可以免费使用并且能用于商业用途</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>1、占有内存少，并发能力强，Nginx的并发能力在同类型的网页服务器中表现较好。</p><p>2、Nginx相较于Apache\lighttpd具有占有内存少</p><p>3、稳定性高等优势，并且依靠并发能力强</p><p>4、有丰富的模块库以及友好灵活的配置</p><p>5、支持热部署。即可以在7×24小时不间断服务的前提下，升级Nginx的可执行文件。当然，它也支持不停止服务就更新配置项、更换日志文件等功能。</p><p>6、可以做反向代理，并且可以支持七层负载均衡</p><h3 id="架构中的作用"><a href="#架构中的作用" class="headerlink" title="架构中的作用"></a><strong>架构中的作用</strong></h3><p><strong>介绍nginx在系统架构（网关入口）中的作用，总结如下：</strong></p><p>1、路由功能（与微服务对应）：域名/路径，进行路由选择后台服务器</p><p>2、负载功能（与高并发高可用对应）：对后台服务器集群进行负载</p><p>3、静态服务器（比tomcat性能高很多）：在mvvm模式中，充当文件读取职责</p><p>总结：实际使用中，这三项功用，会混合使用。比如先分离动静，再路由服务，再负载机器</p><h3 id="正向代理与反向代理"><a href="#正向代理与反向代理" class="headerlink" title="正向代理与反向代理"></a><strong>正向代理与反向代理</strong></h3><p>1、<strong>代理</strong>：意思是一个位于客户端和原始服务器(origin server)之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标(原始服务器)，然后代理向原始服务器转交请求并将获得的内容返回给客户端。</p><p><img src="/2019/11/25/nginx%E5%9F%BA%E7%A1%80/5FB528CD197C4970A0F9249E8D78ABD1" alt="image"></p><p>比如代理律师，代购，政府机关办事的代理人等等。</p><p>2、<strong>反向代理</strong>（Reverse Proxy）方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。</p><p><img src="/2019/11/25/nginx%E5%9F%BA%E7%A1%80/77BEA255FC8448D7856E613B2DF6AFE9" alt="image"></p><hr><h2 id="二，Nginx架构设计"><a href="#二，Nginx架构设计" class="headerlink" title="二，Nginx架构设计"></a><span id="2">二，Nginx架构设计</span></h2><h3 id="2-1。-Nginx的模块化设计"><a href="#2-1。-Nginx的模块化设计" class="headerlink" title="2.1。 Nginx的模块化设计"></a>2.1。 Nginx的模块化设计</h3><p>高度模块化的设计是 Nginx 的架构基础。Nginx<br>服务器被分解为多个模块，每个模块就是一个功能模块，只负责自身的功能，模块之间严格遵循“高内聚，低耦合”的原则。</p><p><img src="/2019/11/25/nginx%E5%9F%BA%E7%A1%80/B2CEA77953F347E096947D224D64249E" alt="image"></p><ul><li><strong>核心模块</strong></li></ul><p>核心模块是 Nginx<br>服务器正常运行必不可少的模块，提供错误日志记录、配置文件解析、事件驱动机制、进程管理等核心功能。</p><ul><li><strong>标准 HTTP 模块</strong></li></ul><p>标准 HTTP 模块提供 HTTP 协议解析相关的功能，如：端口配置、网页编码设置、HTTP<br>响应头设置等。</p><ul><li><strong>可选 HTTP 模块</strong></li></ul><p>可选 HTTP 模块主要用于扩展标准的 HTTP 功能，让 Nginx<br>能处理一些特殊的服务，如：Flash 多媒体传输、解析 GeoIP 请求、SSL 支持等。</p><ul><li><strong>邮件服务模块</strong></li></ul><p>邮件服务模块主要用于支持 Nginx 的邮件服务，包括对 POP3 协议、IMAP 协议和 SMTP<br>协议的支持。</p><ul><li><strong>第三方模块</strong></li></ul><p>第三方模块是为了扩展 Nginx 服务器应用，完成开发者自定义功能，如：Json 支持、Lua<br>支持等。</p><h3 id="2-2-Nginx多进程模型"><a href="#2-2-Nginx多进程模型" class="headerlink" title="2.2. Nginx多进程模型"></a>2.2. Nginx多进程模型</h3><hr><p><img src="/2019/11/25/nginx%E5%9F%BA%E7%A1%80/3BC567D4CE694097922BD4226ECC1983" alt="image"></p><p>1、服务器每当收到一个客户端时。就有服务器主进程（master<br>process）生成一个子进程（worker<br>process）出来和客户端建立连接进行交互，直到连接断开，该子进程结束。</p><p>2、使用进程的好处是各个进程之间相互独立，不需要加锁，减少了使用锁对性能造成影响，同时降低编程的复杂度，降低开发成本。</p><p>其次，采用独立的进程，可以让进程互相之间不会影响，如果一个进程发生异常退出时，其它进程正常工作，master<br>进程则很快启动新的 worker 进程，确保服务不中断，将风险降到最低。</p><p>缺点是操作系统生成一个子进程需要进行内存复制等操作，在资源和时间上会产生一定的开销；当有大量请求时，会导致系统性能下降。</p><h3 id="2-3-Nginx的epoll模式"><a href="#2-3-Nginx的epoll模式" class="headerlink" title="2.3. Nginx的epoll模式"></a>2.3. Nginx的epoll模式</h3><p><img src="/2019/11/25/nginx%E5%9F%BA%E7%A1%80/EB3C80B075DB4ADE8F35DB7B6E011F32" alt="image"></p><p>select和poll的处理模式如上图：</p><p>–在某一时刻，进程收集所有的连接，其实这100万连接中大部分是没有事件发生的。因此，如果每次收集事件时，都把这100万连接的套接字传给操作系统（这首先就是用户态内存到内核内存的大量复制），而由操作系统内核寻找这些链接上没有处理的事件，将会是巨大的浪费。</p><p>而epoll改进了收集连接的动作，提高效率。</p><p><strong>epoll的优点：</strong></p><ul><li><p>支持一个进程打开大数目的socket描述符(FD)</p></li><li><p>IO效率不随FD数目增加而线性下降</p></li><li><p>使用mmap加速内核与用户空间的消息传递</p></li></ul><h2 id="三，nginx安装："><a href="#三，nginx安装：" class="headerlink" title="三，nginx安装："></a><span id="3">三，nginx安装：</span></h2><h3 id="3-1-源码编译方式"><a href="#3-1-源码编译方式" class="headerlink" title="3.1. 源码编译方式"></a>3.1. 源码编译方式</h3><p>安装make：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install autoconf automake make</span><br></pre></td></tr></table></figure><p>安装g++: </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install gcc gcc-c++</span><br></pre></td></tr></table></figure><p>一般系统中已经装了了make和g++，无须再装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">yum -y install pcre pcre-devel</span><br><span class="line"></span><br><span class="line">yum -y install zlib zlib-devel</span><br><span class="line"></span><br><span class="line">yum install -y openssl openssl-devel</span><br></pre></td></tr></table></figure><p>安装nginx依赖的库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">wget http://nginx.org/download/nginx-1.9.15.tar.gz</span><br><span class="line"></span><br><span class="line">tar -zxvf nginx-1.9.15.tar.gz</span><br><span class="line"></span><br><span class="line">cd nginx-1.9.15</span><br><span class="line"></span><br><span class="line">./configure --prefix=/usr/local/nginx --with-http_stub_status_module --with-http_ssl_module</span><br><span class="line"></span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure><p><strong>配置</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">--prefix指定安装目录</span><br><span class="line"></span><br><span class="line">--with-http_ssl_module安装https模块</span><br><span class="line"></span><br><span class="line">creating objs/Makefile 代表编译成功</span><br><span class="line"></span><br><span class="line">make编译</span><br><span class="line"></span><br><span class="line">make install安装</span><br></pre></td></tr></table></figure><h3 id="3-2-yum方式："><a href="#3-2-yum方式：" class="headerlink" title="3.2. yum方式："></a>3.2. <strong>yum方式：</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">centos6：yum install epel-release -y \#yum扩展源</span><br><span class="line"></span><br><span class="line">yum install nginx -y</span><br></pre></td></tr></table></figure><hr><h2 id="四，文件结构以及模型概念："><a href="#四，文件结构以及模型概念：" class="headerlink" title="四，文件结构以及模型概念："></a><span id="4">四，文件结构以及模型概念：</span></h2><h3 id="4-1-目录结构"><a href="#4-1-目录结构" class="headerlink" title="4.1. 目录结构"></a>4.1. 目录结构</h3><ul><li><strong>Conf 配置文件</strong></li><li><strong>Html 网页文件</strong></li><li><strong>Logs 日志文件</strong></li><li><strong>Sbin 二进制程序</strong></li></ul><p><strong>启停命令：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">./nginx -c nginx.conf的文件。如果不指定，默认为NGINX_HOME/conf/nginx.conf</span><br><span class="line"></span><br><span class="line">./nginx -s stop 停止</span><br><span class="line"></span><br><span class="line">./nginx -s quit退出</span><br><span class="line"></span><br><span class="line">./nginx -s reload 重新加载nginx.conf</span><br><span class="line"></span><br><span class="line">./nginx -t 检查配置文件是否正确</span><br></pre></td></tr></table></figure><p><strong>发送信号的方式</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kill -QUIT 进程号 安全停止</span><br><span class="line"></span><br><span class="line">kil -TERM 进程号 立即停止</span><br></pre></td></tr></table></figure><h3 id="4-2-nginx模型概念："><a href="#4-2-nginx模型概念：" class="headerlink" title="4.2. nginx模型概念："></a>4.2. nginx模型概念：</h3><p><strong>Nginx会按需同时运行多个进程：</strong></p><p><img src="/2019/11/25/nginx%E5%9F%BA%E7%A1%80/BAB3479FD5F54DBBBB5C71A811F53F96" alt="image"></p><p>一个主进程(master)和几个工作进程(worker)，配置了缓存时还会有缓存加载器进程(cache<br>loader)和缓存管理器进程(cache manager)等。</p><p>所有进程均是仅含有一个线程，并主要通过“共享内存”的机制实现进程间通信。</p><p>主进程以root用户身份运行，而worker、cache loader和cache<br>manager均应以非特权用户身份（user配置项）运行。</p><p><strong>主进程主要完成如下工作：</strong></p><ol><li>读取并验正配置信息；</li><li>创建、绑定及关闭套接字；</li><li>启动、终止及维护worker进程的个数；</li><li>无须中止服务而重新配置工作特性；</li><li>重新打开日志文件；</li></ol><p><strong>worker进程主要完成的任务包括：</strong></p><ol><li>接收、传入并处理来自客户端的连接；</li><li>提供反向代理及过滤功能；</li><li>nginx任何能完成的其它任务；</li></ol><h3 id="4-3-nginx-conf配置文件结构"><a href="#4-3-nginx-conf配置文件结构" class="headerlink" title="4.3. nginx.conf配置文件结构"></a>4.3. nginx.conf配置文件结构</h3><p><img src="/2019/11/25/nginx%E5%9F%BA%E7%A1%80/498BFE42F9F34978891B411C4F115E22" alt="image"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#user nobody; #主模块命令，</span><br><span class="line">指定Nginx的worker进程运行用户以及用户组，默认由nobody账号运行。</span><br><span class="line"></span><br><span class="line">worker_processes 1;  #指定Nginx要开启的进程数。  根据硬件调整，通常等于CPU数量或者2倍于CPU。</span><br><span class="line"></span><br><span class="line">worker_rlimit_nofile 100000; #worker进程的最大打开文件数限制</span><br><span class="line"></span><br><span class="line">#error_log logs/error.log;</span><br><span class="line"></span><br><span class="line">#error_log logs/error.log notice;</span><br><span class="line"></span><br><span class="line">#error_log logs/error.log info;</span><br><span class="line"></span><br><span class="line">#pid logs/nginx.pid;</span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line"></span><br><span class="line">use epoll;</span><br><span class="line"></span><br><span class="line">worker_connections 1024;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>以上这块配置代码是对nginx全局属性的配置。</strong></p><p><strong>user</strong> :主模块命令，<br>指定Nginx的worker进程运行用户以及用户组，默认由nobody账号运行。</p><p><strong>worker_processes</strong>: 指定Nginx要开启的进程数。</p><p><strong>error log</strong>:用来定义全局错设日志文件的路径和日志名称。</p><blockquote><p>日志输出级别有debug，info，notice，warn，error，crit<br>可供选择，其中debug输出日志最为详细，面crit（严重）输出日志最少。默认是error</p></blockquote><p><strong>pid</strong>: 用来指定进程id的存储文件位置。</p><p><strong>event</strong>：设定nginx的工作模式及连接数上限，</p><blockquote><p>其中参数use用来指定nginx的工作模式（这里是epoll，epoll是多路复用IO(I/O<br>Multiplexing)中的一种方式）,</p></blockquote><blockquote><p>nginx支持的工作模式有select ,poll,kqueue,epoll,rtsig,/dev/poll。</p></blockquote><blockquote><p>其中select和poll都是标准的工作模式，kqueue和epoll是高效的工作模式，对于linux系统，epoll是首选。</p></blockquote><p><strong>worker_connection</strong> : 是设置nginx每个进程最大的连接数，默认是1024，所以nginx最大的连接数max_client=worker_processes * worker_connections。</p><blockquote><p>进程最大连接数受到系统最大打开文件数的限制，需要设置ulimit。</p></blockquote><p><strong>下面部分是nginx对http服务器相关属性的设置</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    include       mime.types;               主模块命令，对配置文件所包含文件的设定，减少主配置文件的复杂度，相当于把部分设置放在别的地方，然后在包含进来，保持主配置文件的简洁</span><br><span class="line">    default_type  application/octet-stream; 默认文件类型，当文件类型未定义时候就使用这类设置的。</span><br><span class="line"></span><br><span class="line">    #log_format  main  &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos;   指定nginx日志的格式</span><br><span class="line">    #                  &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos;</span><br><span class="line">    #                  &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;;</span><br><span class="line"></span><br><span class="line">    #access_log  logs/access.log  main;</span><br><span class="line">    sendfile        on;   开启高效文件传输模式（zero copy 方式），避免内核缓冲区数据和用户缓冲区数据之间的拷贝。</span><br><span class="line">    #tcp_nopush     on;  开启TCP_NOPUSH套接字（sendfile开启时有用）</span><br><span class="line"></span><br><span class="line">    #keepalive_timeout  0;   客户端连接超时时间</span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line"></span><br><span class="line">    #gzip  on;             设置是否开启gzip模块</span><br></pre></td></tr></table></figure><p><strong>下面是server段虚拟主机的配置</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">        listen       80;   虚拟主机的服务端口</span><br><span class="line">        server_name  localhost;   用来指定ip或者域名，多个域名用逗号分开</span><br><span class="line">        #charset koi8-r;</span><br><span class="line">        location / &#123;        </span><br><span class="line">               #地址匹配设置，支持正则匹配，也支持条件匹配，这里是默认请求地址，用户可以location命令对nginx进行动态和静态网页过滤处理</span><br><span class="line">            root   html;                   虚拟主机的网页根目录</span><br><span class="line">            index  index.html index.htm;   默认访问首页文件</span><br><span class="line">        &#125;</span><br><span class="line">        #error_page  404              /404.html;</span><br><span class="line">        # redirect server error pages to the static page /50x.html        </span><br><span class="line">        error_page   500 502 503 504  /50x.html;</span><br><span class="line">        location = /50x.html &#123;</span><br><span class="line">            root   html;</span><br><span class="line">        &#125;     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="五，Nginx日志"><a href="#五，Nginx日志" class="headerlink" title="五，Nginx日志"></a><span id="5">五，Nginx日志</span></h3><p>通过访问日志，你可以得到用户地域来源、跳转来源、使用终端、某个URL访问量等相关信息；通过错误日志，你可以得到系统某个服务或server的性能瓶颈等。因此，将日志好好利用，你可以得到很多有价值的信息。 </p><p><strong>日志格式</strong></p><p>打开nginx.conf配置文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /usr/local/nginx/conf/nginx.conf</span><br></pre></td></tr></table></figure><p>日志部分内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#access_log logs/access.log main;</span><br></pre></td></tr></table></figure><blockquote><p>日志生成的到Nginx根目录logs/access.log文件，默认使用“main”日志格式，也可以自定义格式。</p></blockquote><p><strong>默认“main”日志格式：</strong> 参数明细表：</p><table><thead><tr><th>$remote_addr</th><th>客户端的ip地址(代理服务器，显示代理服务ip)</th></tr></thead><tbody><tr><td>$remote_user</td><td>用于记录远程客户端的用户名称（一般为“-”）</td></tr><tr><td>$time_local</td><td>用于记录访问时间和时区</td></tr><tr><td>$request</td><td>用于记录请求的url以及请求方法</td></tr><tr><td>$status</td><td>响应状态码，例如：200成功、404页面找不到等。</td></tr><tr><td>$body_bytes_sent</td><td>给客户端发送的文件主体内容字节数</td></tr><tr><td>$http_user_agent</td><td>用户所使用的代理（一般为浏览器）</td></tr><tr><td>$http_x_forwarded_for</td><td>可以记录客户端IP，通过代理服务器来记录客户端的ip地址</td></tr><tr><td>$http_referer</td><td>可以记录用户是从哪个链接访问过来的</td></tr></tbody></table><p>查看日志命令tail -f /usr/local/nginx/logs/access.log</p><p><strong>日志配置和及切割</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/etc/init.d/rsyslog start #系统日志，如不开启，看不到定时任务日志</span><br><span class="line"></span><br><span class="line">/etc/rc.d/init.d/crond start #定时任务开启</span><br></pre></td></tr></table></figure><p><strong>编写sh：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line"># 指定日志和切割后日志备份的目录</span><br><span class="line">YEAR=$(date +%Y)</span><br><span class="line">MONTH=$(date +%m)</span><br><span class="line">DAY=$(date +%d)</span><br><span class="line">YESTERDAY=$(date -d &quot;yesterday&quot; +%Y-%m-%d)</span><br><span class="line">LOGS_PATH=/data/nginx/logs</span><br><span class="line">LOGS_BAK_PATH=/data/nginx/logs-bak</span><br><span class="line"></span><br><span class="line"># 得到1级目录名</span><br><span class="line">if [[ $(($DAY)) -eq 1 ]]</span><br><span class="line">  then</span><br><span class="line">    if [[ $(($MONTH)) -eq 1 ]]</span><br><span class="line">      then</span><br><span class="line">        LOGS_BAK_PATH=$LOGS_BAK_PATH/$(($&#123;YEAR&#125;-1))-12</span><br><span class="line">    else</span><br><span class="line">      if [[ $(($MONTH)) -gt 10 ]]</span><br><span class="line">        then</span><br><span class="line">          LOGS_BAK_PATH=$LOGS_BAK_PATH/$&#123;YEAR&#125;-$(($&#123;MONTH&#125;-1))</span><br><span class="line">      else</span><br><span class="line">          LOGS_BAK_PATH=$LOGS_BAK_PATH/$&#123;YEAR&#125;-0$(($&#123;MONTH&#125;-1))</span><br><span class="line">      fi</span><br><span class="line">    fi</span><br><span class="line">else</span><br><span class="line">    LOGS_BAK_PATH=$LOGS_BAK_PATH/$&#123;YEAR&#125;-$&#123;MONTH&#125;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"># 创建目录</span><br><span class="line">mkdir -p $LOGS_BAK_PATH/$&#123;YESTERDAY&#125;</span><br><span class="line"></span><br><span class="line"># 复制当前的日志文件到备份的目录</span><br><span class="line">cp $&#123;LOGS_PATH&#125;/access.log $&#123;LOGS_BAK_PATH&#125;/$&#123;YESTERDAY&#125;/access_$&#123;YESTERDAY&#125;.</span><br><span class="line">log#cp $&#123;LOGS_PATH&#125;/admin_access.log $&#123;LOGS_BAK_PATH&#125;/$&#123;YESTERDAY&#125;/admin_access_</span><br><span class="line">$&#123;YESTERDAY&#125;.logcp $&#123;LOGS_PATH&#125;/error.log $&#123;LOGS_BAK_PATH&#125;/$&#123;YESTERDAY&#125;/error_$&#123;YESTERDAY&#125;.lo</span><br><span class="line">g</span><br><span class="line"># 清空日志</span><br><span class="line">&gt; $&#123;LOGS_PATH&#125;/access.log</span><br><span class="line">#&gt; $&#123;LOGS_PATH&#125;/admin_access.log</span><br><span class="line">&gt; $&#123;LOGS_PATH&#125;/error.log</span><br></pre></td></tr></table></figure><p><strong>配置cron：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*/1 * * * * /usr/local/nginx/sbin/logcut.sh</span><br></pre></td></tr></table></figure><p><strong>拓展</strong></p><blockquote><p>kill命令格式：<br>kill 是向进程发送信号的命令。<br>Nginx的信号<br>1）、TERM、INT 快速关闭；<br>2）、QUIT从容关闭；<br>3）、HUP平滑重启，重新加载配置文件；<br>4）、USR1 重新打开日志文件；<br>5）、USR2 平滑升级可执行程序；<br>KILL 9 强制终止，直接杀</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;nginx基础&quot;&gt;&lt;a href=&quot;#nginx基础&quot; class=&quot;headerlink&quot; title=&quot;nginx基础&quot;&gt;&lt;/a&gt;nginx基础&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1&quot;&gt;一、Nginx简介&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=
      
    
    </summary>
    
    
      <category term="分布式专题" scheme="https://hicker000.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%93%E9%A2%98/"/>
    
    
      <category term="Nginx" scheme="https://hicker000.github.io/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot Actuator监控端点</title>
    <link href="https://hicker000.github.io/2019/11/10/Spring-Boot-Actuator%E7%9B%91%E6%8E%A7%E7%AB%AF%E7%82%B9/"/>
    <id>https://hicker000.github.io/2019/11/10/Spring-Boot-Actuator%E7%9B%91%E6%8E%A7%E7%AB%AF%E7%82%B9/</id>
    <published>2019-11-10T09:25:45.000Z</published>
    <updated>2019-11-10T09:29:21.369Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Spring-Boot-Actuator监控端点"><a href="#Spring-Boot-Actuator监控端点" class="headerlink" title="Spring Boot Actuator监控端点"></a>Spring Boot Actuator监控端点</h2><ul><li><a href="#1">一,初识Actuator</a></li><li><a href="#2">二,原生端点</a><ul><li><a href="#2.1">2.1 应用配置类</a><ul><li><a href="#2.1.1">autoconfig</a></li><li><a href="#2.1.2">beans</a></li><li><a href="#2.1.3">configprops</a></li><li><a href="#2.1.4">env</a></li><li><a href="#2.1.5">mappings</a></li><li><a href="#2.1.6">info</a></li></ul></li><li><a href="#2.2">2.2 度量指标类</a><ul><li><a href="#2.2.1">metrics</a></li><li><a href="#2.2.2">health</a></li><li><a href="#2.2.3">dump</a></li><li><a href="#2.2.4">trace</a></li></ul></li><li><a href="#2.3">2.3 操作控制类</a></li></ul></li></ul><p>在Spring Boot的众多Starter POMs中有一个特殊的模块，它不同于其他模块那样大多用于开发业务功能或是连接一些其他外部资源。它完全是一个用于暴露自身信息的模块，所以很明显，它的主要作用是用于监控与管理，它就是：spring-boot-starter-actuator。</p><h2 id="一-初识Actuator"><a href="#一-初识Actuator" class="headerlink" title="一,初识Actuator"></a><span id="1">一,初识Actuator</span></h2><p>下面，我们可以通过对快速入门中实现的Spring Boot应用增加spring-boot-starter-actuator模块功能，来对它有一个直观的认识。</p><p>在现有的Spring Boot应用中引入该模块非常简单，只需要在pom.xml的dependencies节点中，新增spring-boot-starter-actuator的依赖即可，具体如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>通过增加该依赖之后，重新启动应用。此时，我们可以在控制台中看到如下图所示的输出：</p><p><img src="/2019/11/10/Spring-Boot-Actuator%E7%9B%91%E6%8E%A7%E7%AB%AF%E7%82%B9/B73FD621480E4DAF95FFDD0690A8D669" alt="image"></p><p>上图显示了一批端点定义，这些端点并非我们自己在程序中创建，而是由spring-boot-starter-actuator模块根据应用依赖和配置自动创建出来的监控和管理端点。通过这些端点，我们可以实时的获取应用的各项监控指标，比如：访问<br>==/health==端点，我们可以获得如下返回的应用健康信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;status&quot;: &quot;UP&quot;,</span><br><span class="line">    &quot;diskSpace&quot;: &#123;</span><br><span class="line">        &quot;status&quot;: &quot;UP&quot;,</span><br><span class="line">        &quot;total&quot;: 491270434816,</span><br><span class="line">        &quot;free&quot;: 383870214144,</span><br><span class="line">        &quot;threshold&quot;: 10485760</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二-原生端点"><a href="#二-原生端点" class="headerlink" title="二,原生端点"></a><span id="2">二,原生端点</span></h2><p>通过在快速入门示例中添加==spring-boot-starter-actuator==模块，我们已经对它有了一个初步的认识。接下来，我们详细介绍一下==spring-boot-starter-actuator==模块中已经实现的一些原生端点。如果根据端点的作用来说，我们可以原生端点分为三大类：</p><ul><li>应用配置类：获取应用程序中加载的应用配置、环境变量、自动化配置报告等与Spring Boot应用密切相关的配置类信息。</li><li>度量指标类：获取应用程序运行过程中用于监控的度量指标，比如：内存信息、线程池信息、HTTP请求统计等。</li><li>操作控制类：提供了对应用的关闭等操作类功能。</li></ul><p>下面我们来详细了解一下这三类端点都分别可以为我们提供怎么样的有用信息和强大功能，以及我们如何去扩展和配置它们。</p><h3 id="2-1-应用配置类"><a href="#2-1-应用配置类" class="headerlink" title="2.1 应用配置类"></a><span id="2.1">2.1 应用配置类</span></h3><p>由于Spring Boot为了改善传统Spring应用繁杂的配置内容，采用了包扫描和自动化配置的机制来加载原本集中于xml文件中的各项内容。虽然这样的做法，让我们的代码变得非常简洁，但是整个应用的实例创建和依赖关系等信息都被离散到了各个配置类的注解上，这使得我们分析整个应用中资源和实例的各种关系变得非常的困难。而这类端点就可以帮助我们轻松的获取一系列关于Spring 应用配置内容的详细报告，比如：自动化配置的报告、Bean创建的报告、环境属性的报告等。</p><h4 id="autoconfig："><a href="#autoconfig：" class="headerlink" title="/autoconfig："></a><span id="2.1.1">/autoconfig：</span></h4><p>该端点用来获取应用的自动化配置报告，其中包括所有自动化配置的候选项。同时还列出了每个候选项自动化配置的各个先决条件是否满足。所以，该端点可以帮助我们方便的找到一些自动化配置为什么没有生效的具体原因。该报告内容将自动化配置内容分为两部分：</p><ul><li><strong>positiveMatches</strong>中返回的是条件匹配成功的自动化配置</li><li><strong>negativeMatches</strong>中返回的是条件匹配不成功的自动化配置</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;positiveMatches&quot;: &#123; // 条件匹配成功的</span><br><span class="line">        &quot;EndpointWebMvcAutoConfiguration&quot;: [</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;condition&quot;: &quot;OnClassCondition&quot;,</span><br><span class="line">                &quot;message&quot;: &quot;@ConditionalOnClass classes found: javax.servlet.Servlet,org.springframework.web.servlet.DispatcherServlet&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;condition&quot;: &quot;OnWebApplicationCondition&quot;,</span><br><span class="line">                &quot;message&quot;: &quot;found web application StandardServletEnvironment&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">        ...</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;negativeMatches&quot;: &#123;  // 条件不匹配成功的</span><br><span class="line">        &quot;HealthIndicatorAutoConfiguration.DataSourcesHealthIndicatorConfiguration&quot;: [</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;condition&quot;: &quot;OnClassCondition&quot;,</span><br><span class="line">                &quot;message&quot;: &quot;required @ConditionalOnClass classes not found: org.springframework.jdbc.core.JdbcTemplate&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从如上示例中我们可以看到，每个自动化配置候选项中都有一系列的条件，比如上面没有成功匹配的==HealthIndicatorAutoConfiguration.DataSourcesHealthIndicatorConfiguration==配置，它的先决条件就是需要在工程中包含==org.springframework.jdbc.core.JdbcTemplate==类，由于我们没有引入相关的依赖，它就不会执行自动化配置内容。所以，当我们发现有一些期望的配置没有生效时，就可以通过该端点来查看没有生效的具体原因。</p><h4 id="beans："><a href="#beans：" class="headerlink" title="/beans："></a><span id="2.1.2">/beans：</span></h4><p>该端点用来获取应用上下文中创建的所有Bean。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;context&quot;: &quot;hello:dev:8881&quot;,</span><br><span class="line">        &quot;parent&quot;: null,</span><br><span class="line">        &quot;beans&quot;: [</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;bean&quot;: &quot;org.springframework.boot.autoconfigure.web.DispatcherServletAutoConfiguration$DispatcherServletConfiguration&quot;,</span><br><span class="line">                &quot;scope&quot;: &quot;singleton&quot;,</span><br><span class="line">                &quot;type&quot;: &quot;org.springframework.boot.autoconfigure.web.DispatcherServletAutoConfiguration$DispatcherServletConfiguration$$EnhancerBySpringCGLIB$$3440282b&quot;,</span><br><span class="line">                &quot;resource&quot;: &quot;null&quot;,</span><br><span class="line">                &quot;dependencies&quot;: [</span><br><span class="line">                    &quot;serverProperties&quot;,</span><br><span class="line">                    &quot;spring.mvc.CONFIGURATION_PROPERTIES&quot;,</span><br><span class="line">                    &quot;multipartConfigElement&quot;</span><br><span class="line">                ]</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;bean&quot;: &quot;dispatcherServlet&quot;,</span><br><span class="line">                &quot;scope&quot;: &quot;singleton&quot;,</span><br><span class="line">                &quot;type&quot;: &quot;org.springframework.web.servlet.DispatcherServlet&quot;,</span><br><span class="line">                &quot;resource&quot;: &quot;class path resource [org/springframework/boot/autoconfigure/web/DispatcherServletAutoConfiguration$DispatcherServletConfiguration.class]&quot;,</span><br><span class="line">                &quot;dependencies&quot;: []</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>如上示例中，我们可以看到在每个bean中都包含了下面这几个信息：</p><ul><li><strong>bean</strong>：Bean的名称</li><li><strong>scope</strong>：Bean的作用域</li><li><strong>type</strong>：Bean的Java类型</li><li><strong>reource</strong>：class文件的具体路径</li><li><strong>dependencies</strong>：依赖的Bean名称</li></ul><h4 id="configprops："><a href="#configprops：" class="headerlink" title="/configprops："></a><span id="2.1.3">/configprops：</span></h4><p>该端点用来获取应用中配置的属性信息报告。从下面该端点返回示例的片段中，我们看到返回了关于该短信的配置信息，prefix属性代表了属性的配置前缀，properties代表了各个属性的名称和值。所以，我们可以通过该报告来看到各个属性的配置路径，比如我们要关闭该端点，就可以通过使用==endpoints.configprops.enabled=false==来完成设置。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;configurationPropertiesReportEndpoint&quot;: &#123;</span><br><span class="line">        &quot;prefix&quot;: &quot;endpoints.configprops&quot;,</span><br><span class="line">        &quot;properties&quot;: &#123;</span><br><span class="line">            &quot;id&quot;: &quot;configprops&quot;,</span><br><span class="line">            &quot;sensitive&quot;: true,</span><br><span class="line">            &quot;enabled&quot;: true</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="env："><a href="#env：" class="headerlink" title="/env："></a><span id="2.1.4">/env：</span></h4><p>该端点与<br>==/configprops==不同，它用来获取应用所有可用的环境属性报告。包括：环境变量、JVM属性、应用的配置配置、命令行中的参数。从下面该端点返回的示例片段中，我们可以看到它不仅返回了应用的配置属性，还返回了系统属性、环境变量等丰富的配置信息，其中也包括了应用还没有没有使用的配置。所以它可以帮助我们方便地看到当前应用可以加载的配置信息，并配合<br>==@ConfigurationProperties==注解将它们引入到我们的应用程序中来进行使用。另外，为了配置属性的安全，对于一些类似密码等敏感信息，该端点都会进行隐私保护，但是我们需要让属性名中包含：password、secret、key这些关键词，这样该端点在返回它们的时候会使用*来替代实际的属性值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;profiles&quot;: [</span><br><span class="line">        &quot;dev&quot;</span><br><span class="line">    ],</span><br><span class="line">    &quot;server.ports&quot;: &#123;</span><br><span class="line">        &quot;local.server.port&quot;: 8881</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;servletContextInitParams&quot;: &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;systemProperties&quot;: &#123;</span><br><span class="line">        &quot;idea.version&quot;: &quot;2016.1.3&quot;,</span><br><span class="line">        &quot;java.runtime.name&quot;: &quot;Java(TM) SE Runtime Environment&quot;,</span><br><span class="line">        &quot;sun.boot.library.path&quot;: &quot;C:\\Program Files\\Java\\jdk1.8.0_91\\jre\\bin&quot;,</span><br><span class="line">        &quot;java.vm.version&quot;: &quot;25.91-b15&quot;,</span><br><span class="line">        &quot;java.vm.vendor&quot;: &quot;Oracle Corporation&quot;,</span><br><span class="line">        ...</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;systemEnvironment&quot;: &#123;</span><br><span class="line">        &quot;configsetroot&quot;: &quot;C:\\WINDOWS\\ConfigSetRoot&quot;,</span><br><span class="line">        &quot;RABBITMQ_BASE&quot;: &quot;E:\\tools\\rabbitmq&quot;,</span><br><span class="line">        ...</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;applicationConfig: [classpath:/application-dev.properties]&quot;: &#123;</span><br><span class="line">        &quot;server.port&quot;: &quot;8881&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;applicationConfig: [classpath:/application.properties]&quot;: &#123;</span><br><span class="line">        &quot;server.port&quot;: &quot;8885&quot;,</span><br><span class="line">        &quot;spring.profiles.active&quot;: &quot;dev&quot;,</span><br><span class="line">        &quot;info.app.name&quot;: &quot;spring-boot-hello&quot;,</span><br><span class="line">        &quot;info.app.version&quot;: &quot;v1.0.0&quot;,</span><br><span class="line">        &quot;spring.application.name&quot;: &quot;hello&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="mappings："><a href="#mappings：" class="headerlink" title="/mappings："></a><span id="2.1.5">/mappings：</span></h4><p>该端点用来返回所有Spring MVC的控制器映射关系报告。从下面的示例片段中，我们可以看该报告的信息与我们在启用Spring MVC的Web应用时输出的日志信息类似，其中bean属性标识了该映射关系的请求处理器，method属性标识了该映射关系的具体处理类和处理函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;/webjars/**&quot;: &#123;</span><br><span class="line">        &quot;bean&quot;: &quot;resourceHandlerMapping&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;/**&quot;: &#123;</span><br><span class="line">        &quot;bean&quot;: &quot;resourceHandlerMapping&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;/**/favicon.ico&quot;: &#123;</span><br><span class="line">        &quot;bean&quot;: &quot;faviconHandlerMapping&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;&#123;[/hello]&#125;&quot;: &#123;</span><br><span class="line">        &quot;bean&quot;: &quot;requestMappingHandlerMapping&quot;,</span><br><span class="line">        &quot;method&quot;: &quot;public java.lang.String com.didispace.web.HelloController.index()&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;&#123;[/mappings || /mappings.json],methods=[GET],produces=[application/json]&#125;&quot;: &#123;</span><br><span class="line">        &quot;bean&quot;: &quot;endpointHandlerMapping&quot;,</span><br><span class="line">        &quot;method&quot;: &quot;public java.lang.Object org.springframework.boot.actuate.endpoint.mvc.EndpointMvcAdapter.invoke()&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="info："><a href="#info：" class="headerlink" title="/info："></a><span id="2.1.6">/info：</span></h4><p>该端点用来返回一些应用自定义的信息。默认情况下，该端点只会返回一个空的json内容。我们可以在==application.properties==配置文件中通过info前缀来设置一些属性，比如下面这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">info.app.name=spring-boot-hello</span><br><span class="line">info.app.version=v1.0.0</span><br></pre></td></tr></table></figure><p>再访问/info端点，我们可以得到下面的返回报告，其中就包含了上面我们在应用自定义的两个参数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;app&quot;: &#123;</span><br><span class="line">        &quot;name&quot;: &quot;spring-boot-hello&quot;,</span><br><span class="line">        &quot;version&quot;: &quot;v1.0.0&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="2-2-度量指标类"><a href="#2-2-度量指标类" class="headerlink" title="2.2 度量指标类"></a><span id="2.2">2.2 度量指标类</span></h3><p>上面我们所介绍的应用配置类端点所提供的信息报告在应用启动的时候都已经基本确定了其返回内容，可以说是一个静态报告。而度量指标类端点提供的报告内容则是动态变化的，这些端点提供了应用程序在运行过程中的一些快照信息，比如：内存使用情况、HTTP请求统计、外部资源指标等。这些端点对于我们构建微服务架构中的监控系统非常有帮助，由于Spring Boot应用自身实现了这些端点，所以我们可以很方便地利用它们来收集我们想要的信息，以制定出各种自动化策略。下面，我们就来分别看看这些强大的端点功能。</p><h4 id="metrics："><a href="#metrics：" class="headerlink" title="/metrics："></a><span id="2.2.1">/metrics：</span></h4><p>该端点用来返回当前应用的各类重要度量指标，比如：内存信息、线程信息、垃圾回收信息等。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;mem&quot;: 541305,</span><br><span class="line">  &quot;mem.free&quot;: 317864,</span><br><span class="line">  &quot;processors&quot;: 8,</span><br><span class="line">  &quot;instance.uptime&quot;: 33376471,</span><br><span class="line">  &quot;uptime&quot;: 33385352,</span><br><span class="line">  &quot;systemload.average&quot;: -1,</span><br><span class="line">  &quot;heap.committed&quot;: 476672,</span><br><span class="line">  &quot;heap.init&quot;: 262144,</span><br><span class="line">  &quot;heap.used&quot;: 158807,</span><br><span class="line">  &quot;heap&quot;: 3701248,</span><br><span class="line">  &quot;nonheap.committed&quot;: 65856,</span><br><span class="line">  &quot;nonheap.init&quot;: 2496,</span><br><span class="line">  &quot;nonheap.used&quot;: 64633,</span><br><span class="line">  &quot;nonheap&quot;: 0,</span><br><span class="line">  &quot;threads.peak&quot;: 22,</span><br><span class="line">  &quot;threads.daemon&quot;: 20,</span><br><span class="line">  &quot;threads.totalStarted&quot;: 26,</span><br><span class="line">  &quot;threads&quot;: 22,</span><br><span class="line">  &quot;classes&quot;: 7669,</span><br><span class="line">  &quot;classes.loaded&quot;: 7669,</span><br><span class="line">  &quot;classes.unloaded&quot;: 0,</span><br><span class="line">  &quot;gc.ps_scavenge.count&quot;: 7,</span><br><span class="line">  &quot;gc.ps_scavenge.time&quot;: 118,</span><br><span class="line">  &quot;gc.ps_marksweep.count&quot;: 2,</span><br><span class="line">  &quot;gc.ps_marksweep.time&quot;: 234,</span><br><span class="line">  &quot;httpsessions.max&quot;: -1,</span><br><span class="line">  &quot;httpsessions.active&quot;: 0,</span><br><span class="line">  &quot;gauge.response.beans&quot;: 55,</span><br><span class="line">  &quot;gauge.response.env&quot;: 10,</span><br><span class="line">  &quot;gauge.response.hello&quot;: 5,</span><br><span class="line">  &quot;gauge.response.metrics&quot;: 4,</span><br><span class="line">  &quot;gauge.response.configprops&quot;: 153,</span><br><span class="line">  &quot;gauge.response.star-star&quot;: 5,</span><br><span class="line">  &quot;counter.status.200.beans&quot;: 1,</span><br><span class="line">  &quot;counter.status.200.metrics&quot;: 3,</span><br><span class="line">  &quot;counter.status.200.configprops&quot;: 1,</span><br><span class="line">  &quot;counter.status.404.star-star&quot;: 2,</span><br><span class="line">  &quot;counter.status.200.hello&quot;: 11,</span><br><span class="line">  &quot;counter.status.200.env&quot;: 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的示例中，我们看到有这些重要的度量值：</p><ul><li><strong>系统信息</strong>：包括处理器数量processors、运行时间uptime和instance.uptime、系统平均负载systemload.average。</li><li><strong>mem.*</strong>：内存概要信息，包括分配给应用的总内存数量以及当前空闲的内存数量。这些信息来自java.lang.Runtime。</li><li><strong>heap.*</strong>：堆内存使用情况。这些信息来自java.lang.management.MemoryMXBean接口中getHeapMemoryUsage方法获取的java.lang.management.MemoryUsage。</li><li><strong>nonheap.*</strong>：非堆内存使用情况。这些信息来自java.lang.management.MemoryMXBean接口中getNonHeapMemoryUsage方法获取的java.lang.management.MemoryUsage。</li><li><strong>threads.*</strong>：线程使用情况，包括线程数、守护线程数（daemon）、线程峰值（peak）等，这些数据均来自java.lang.management.ThreadMXBean。</li><li><strong>classes.*</strong>：应用加载和卸载的类统计。这些数据均来自java.lang.management.ClassLoadingMXBean。</li><li><strong>gc.*</strong>：垃圾收集器的详细信息，包括垃圾回收次数gc.ps_scavenge.count、垃圾回收消耗时间gc.ps_scavenge.time、标记-清除算法的次数gc.ps_marksweep.count、标记-清除算法的消耗时间gc.ps_marksweep.time。这些数据均来自java.lang.management.GarbageCollectorMXBean。</li><li><strong>httpsessions.*</strong>：Tomcat容器的会话使用情况。包括最大会话数httpsessions.max和活跃会话数httpsessions.active。该度量指标信息仅在引入了嵌入式Tomcat作为应用容器的时候才会提供。</li><li><strong>gauge.*</strong>：HTTP请求的性能指标之一，它主要用来反映一个绝对数值。比如上面示例中的gauge.response.hello: 5，它表示上一次hello请求的延迟时间为5毫秒。</li><li><strong>counter.*</strong>：HTTP请求的性能指标之一，它主要作为计数器来使用，记录了增加量和减少量。如上示例中counter.status.200.hello: 11，它代表了hello请求返回200状态的次数为11。</li></ul><p>对于<strong>gauge.*</strong>和<strong>counter.*</strong>的统计，这里有一个特殊的内容请求star-star，它代表了对静态资源的访问。这两类度量指标非常有用，我们不仅可以使用它默认的统计指标，还可以在程序中轻松的增加自定义统计值。只需要通过注入==org.springframework.boot.actuate.metrics.CounterService和org.springframework.boot.actuate.metrics.GaugeService==来实现自定义的统计指标信息。比如：我们可以像下面这样自定义实现对hello接口的访问次数统计。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class HelloController &#123;</span><br><span class="line">    </span><br><span class="line">    @Autowired</span><br><span class="line">    private CounterService counterService;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;/hello&quot;)</span><br><span class="line">    public String greet() &#123;</span><br><span class="line">        counterService.increment(&quot;didispace.hello.count&quot;);</span><br><span class="line">        return &quot;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>/metrics端点可以提供应用运行状态的完整度量指标报告，这项功能非常的实用，但是对于监控系统中的各项监控功能，它们的监控内容、数据收集频率都有所不同，如果我们每次都通过全量获取报告的方式来收集，略显粗暴。所以，我们还可以通过/metrics/{name}接口来更细粒度的获取度量信息，比如我们可以通过访问/metrics/mem.free来获取当前可用内存数量。</p><h4 id="health："><a href="#health：" class="headerlink" title="/health："></a><span id="2.2.2">/health：</span></h4><p>该端点在一开始的示例中我们已经使用过了，它用来获取应用的各类健康指标信息。在spring-boot-starter-actuator模块中自带实现了一些常用资源的健康指标检测器。这些检测器都通过HealthIndicator接口实现，并且会根据依赖关系的引入实现自动化装配，比如用于检测磁盘的DiskSpaceHealthIndicator、检测DataSource连接是否可用的DataSourceHealthIndicator等。有时候，我们可能还会用到一些Spring Boot的Starter POMs中还没有封装的产品来进行开发，比如：当使用RocketMQ作为消息代理时，由于没有自动化配置的检测器，所以我们需要自己来实现一个用来采集健康信息的检测器。比如，我们可以在Spring Boot的应用中，为org.springframework.boot.actuate.health.HealthIndicator接口实现一个对RocketMQ的检测器类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class RocketMQHealthIndicator implements HealthIndicator &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Health health() &#123;</span><br><span class="line">        int errorCode = check();</span><br><span class="line">        if (errorCode != 0) &#123;</span><br><span class="line">          return Health.down().withDetail(&quot;Error Code&quot;, errorCode).build();</span><br><span class="line">        &#125;</span><br><span class="line">        return Health.up().build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  private int check() &#123;</span><br><span class="line">     // 对监控对象的检测操作</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过重写health()函数来实现健康检查，返回的Heath对象中，共有两项内容，一个是状态信息，除了该示例中的UP与DOWN之外，还有UNKNOWN和OUT_OF_SERVICE，可以根据需要来实现返回；还有一个详细信息，采用Map的方式存储，在这里通过withDetail函数，注入了一个Error Code信息，我们也可以填入一下其他信息，比如，检测对象的IP地址、端口等。重新启动应用，并访问/health接口，我们在返回的JSON字符串中，将会包含了如下信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;rocketMQ&quot;: &#123;</span><br><span class="line">  &quot;status&quot;: &quot;UP&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="dump："><a href="#dump：" class="headerlink" title="/dump："></a><span id="2.2.3">/dump：</span></h4><p>该端点用来暴露程序运行中的线程信息。它使用java.lang.management.ThreadMXBean的dumpAllThreads方法来返回所有含有同步信息的活动线程详情。</p><h4 id="trace："><a href="#trace：" class="headerlink" title="/trace："></a><span id="2.2.4">/trace：</span></h4><p>该端点用来返回基本的HTTP跟踪信息。默认情况下，跟踪信息的存储采用org.springframework.boot.actuate.trace.InMemoryTraceRepository实现的内存方式，始终保留最近的100条请求记录。它记录的内容格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;timestamp&quot;: 1482570022463,</span><br><span class="line">        &quot;info&quot;: &#123;</span><br><span class="line">            &quot;method&quot;: &quot;GET&quot;,</span><br><span class="line">            &quot;path&quot;: &quot;/metrics/mem&quot;,</span><br><span class="line">            &quot;headers&quot;: &#123;</span><br><span class="line">                &quot;request&quot;: &#123;</span><br><span class="line">                    &quot;host&quot;: &quot;localhost:8881&quot;,</span><br><span class="line">                    &quot;connection&quot;: &quot;keep-alive&quot;,</span><br><span class="line">                    &quot;cache-control&quot;: &quot;no-cache&quot;,</span><br><span class="line">                    &quot;user-agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/53.0.2785.143 Safari/537.36&quot;,</span><br><span class="line">                    &quot;postman-token&quot;: &quot;9817ea4d-ad9d-b2fc-7685-9dff1a1bc193&quot;,</span><br><span class="line">                    &quot;accept&quot;: &quot;*/*&quot;,</span><br><span class="line">                    &quot;accept-encoding&quot;: &quot;gzip, deflate, sdch&quot;,</span><br><span class="line">                    &quot;accept-language&quot;: &quot;zh-CN,zh;q=0.8&quot;</span><br><span class="line">                &#125;,</span><br><span class="line">                &quot;response&quot;: &#123;</span><br><span class="line">                    &quot;X-Application-Context&quot;: &quot;hello:dev:8881&quot;,</span><br><span class="line">                    &quot;Content-Type&quot;: &quot;application/json;charset=UTF-8&quot;,</span><br><span class="line">                    &quot;Transfer-Encoding&quot;: &quot;chunked&quot;,</span><br><span class="line">                    &quot;Date&quot;: &quot;Sat, 24 Dec 2016 09:00:22 GMT&quot;,</span><br><span class="line">                    &quot;status&quot;: &quot;200&quot;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    ...</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="2-3-操作控制类"><a href="#2-3-操作控制类" class="headerlink" title="2.3 操作控制类"></a><span id="2.3">2.3 操作控制类</span></h3><p>仔细的读者可能会发现，我们在“初识Actuator”时运行示例的控制台中输出的所有监控端点，已经在介绍应用配置类端点和度量指标类端点时都讲解完了。那么还有哪些是操作控制类端点呢？实际上，由于之前介绍的所有端点都是用来反映应用自身的属性或是运行中的状态，相对于操作控制类端点没有那么敏感，所以他们默认都是启用的。而操作控制类端点拥有更强大的控制能力，如果要使用它们的话，需要通过属性来配置开启。</p><p>在原生端点中，只提供了一个用来关闭应用的端点：/shutdown。我们可以通过如下配置开启它：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">endpoints.shutdown.enabled=true</span><br></pre></td></tr></table></figure><p>在配置了上述属性之后，只需要访问该应用的/shutdown端点就能实现关闭该应用的远程操作。由于开放关闭应用的操作本身是一件非常危险的事，所以真正在线上使用的时候，我们需要对其加入一定的保护机制，比如：定制Actuator的端点路径、整合Spring Security进行安全校验等。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Spring-Boot-Actuator监控端点&quot;&gt;&lt;a href=&quot;#Spring-Boot-Actuator监控端点&quot; class=&quot;headerlink&quot; title=&quot;Spring Boot Actuator监控端点&quot;&gt;&lt;/a&gt;Spring Boot Ac
      
    
    </summary>
    
    
      <category term="微服务" scheme="https://hicker000.github.io/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    
      <category term="SpringBoot" scheme="https://hicker000.github.io/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://hicker000.github.io/2019/11/10/hello-world/"/>
    <id>https://hicker000.github.io/2019/11/10/hello-world/</id>
    <published>2019-11-10T05:30:39.000Z</published>
    <updated>2019-11-10T08:13:48.919Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="发大水发达"><a href="#发大水发达" class="headerlink" title="发大水发达"></a>发大水发达</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
      <category term="测试" scheme="https://hicker000.github.io/categories/%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="测试-1" scheme="https://hicker000.github.io/tags/%E6%B5%8B%E8%AF%95-1/"/>
    
  </entry>
  
</feed>
