<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="https://www.w3.org/2005/Atom">
  <title>jthu的博客</title>
  
  <subtitle>后端技术</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://hicker000.github.io/"/>
  <updated>2019-11-10T08:13:48.919Z</updated>
  <id>https://hicker000.github.io/</id>
  
  <author>
    <name>jthu</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Hello World</title>
    <link href="https://hicker000.github.io/2019/11/10/hello-world/"/>
    <id>https://hicker000.github.io/2019/11/10/hello-world/</id>
    <published>2019-11-10T05:30:39.000Z</published>
    <updated>2019-11-10T08:13:48.919Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="发大水发达"><a href="#发大水发达" class="headerlink" title="发大水发达"></a>发大水发达</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
      <category term="测试" scheme="https://hicker000.github.io/categories/%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="测试-1" scheme="https://hicker000.github.io/tags/%E6%B5%8B%E8%AF%95-1/"/>
    
  </entry>
  
  <entry>
    <title>线程基础、线程之间的共享和协作</title>
    <link href="https://hicker000.github.io/2019/11/10/%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%E3%80%81%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B1%E4%BA%AB%E5%92%8C%E5%8D%8F%E4%BD%9C/"/>
    <id>https://hicker000.github.io/2019/11/10/%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%E3%80%81%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B1%E4%BA%AB%E5%92%8C%E5%8D%8F%E4%BD%9C/</id>
    <published>2019-11-10T05:30:39.000Z</published>
    <updated>2019-11-10T08:11:36.087Z</updated>
    
    <content type="html"><![CDATA[<h1 id="线程基础、线程之间的共享和协作"><a href="#线程基础、线程之间的共享和协作" class="headerlink" title="线程基础、线程之间的共享和协作"></a>线程基础、线程之间的共享和协作</h1><!-- GFM-TOC --><ul><li><a href="#1">一、基础概念</a><ul><li><a href="#1.1">什么是进程和线程</a></li><li><a href="#1.2">核心数和线程数的关系</a></li><li><a href="#1.3">时间片轮转机制</a></li><li><a href="#1.4">澄清并行和并发</a></li><li><a href="#1.5">高并发编程的意义</a></li><li><a href="#1.6">多线程程序需要注意事项</a></li></ul></li><li><a href="#2">二、认识Java里的线程</a><ul><li><a href="#2.1">Java程序天生就是多线程的</a>  </li><li><a href="#2.2">线程的启动与中止</a></li></ul></li><li><a href="#3">三、对Java里的线程再多一点点认识</a><ul><li><a href="#3.1">深入理解run()和start()</a></li><li><a href="#3.2">其他的线程相关方法</a></li><li><a href="#3.3">join方法</a></li><li><a href="#3.4">线程的优先级</a></li><li><a href="#3.5">守护线程</a></li></ul></li><li><a href="#4">四、线程间的共享和协作</a><ul><li><a href="#4.1">线程间的共享</a></li><li><a href="#4.2">ThreadLocal辨析</a></li><li><a href="#4.3">线程间的协作</a></li></ul></li></ul><!-- GFM-TOC --><h3 id="一、基础概念"><a href="#一、基础概念" class="headerlink" title="一、基础概念"></a><h3 id="1">一、基础概念</h3></h3><h5 id="什么是进程和线程"><a href="#什么是进程和线程" class="headerlink" title="什么是进程和线程"></a><h4 id="1.1">什么是进程和线程</h5></h5><h5 id="1-进程是程序运行资源分配的最小单位"><a href="#1-进程是程序运行资源分配的最小单位" class="headerlink" title="1,进程是程序运行资源分配的最小单位"></a>1,进程是程序运行资源分配的最小单位</h5><blockquote><ul><li>进程是操作系统进行资源分配的最小单位,其中资源包括:CPU、内存空间、磁盘IO等,同一进程中的多条线程共享该进程中的全部系统资源,而进程和进程之间是相互独立的。进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位。</li><li>进程是程序在计算机上的一次执行活动。当你运行一个程序,你就启动了一个进程。显然,程序是死的、静态的,进程是活的、动态的。进程可以分为系统进程和用户进程。凡是用于完成操作系统的各种功能的进程就是系统进程,它们就是处于运行状态下的操作系统本身,用户进程就是所有由你启动的进程。</li></ul></blockquote><h5 id="2-线程是CPU调度的最小单位-必须依赖于进程而存在"><a href="#2-线程是CPU调度的最小单位-必须依赖于进程而存在" class="headerlink" title="2,线程是CPU调度的最小单位,必须依赖于进程而存在"></a>2,线程是CPU调度的最小单位,必须依赖于进程而存在</h5><blockquote><p>线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的、能独立运行的基本单位。线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。</p></blockquote><h5 id="3-线程无处不在"><a href="#3-线程无处不在" class="headerlink" title="3,线程无处不在"></a>3,线程无处不在</h5><blockquote><p>任何一个程序都必须要创建线程,特别是Java不管任何程序都必须启动一个main函数的主线程; Java Web开发里面的定时任务、定时器、JSP和 Servlet、异步消息处理机制,远程访问接口RM等,任何一个监听事件, onclick的触发事件等都离不开线程和并发的知识。</p></blockquote><h5 id="核心数和线程数的关系"><a href="#核心数和线程数的关系" class="headerlink" title="核心数和线程数的关系"></a><h4 id="1.2">核心数和线程数的关系</h5></h5><blockquote><ul><li><strong>多核心</strong> : 也指单芯片多处理器( Chip Multiprocessors,简称CMP),CMP是由美国斯坦福大学提出的,其思想是将大规模并行处理器中的SMP(对称多处理器)集成到同一芯片内,各个处理器并行执行不同的进程。这种依靠多个CPU同时并行地运行程序是实现超高速计算的一个重要方向,称为并行处理</li><li><strong>多线程</strong> : Simultaneous Multithreading.简称SMT.让同一个处理器上的多个线程同步执行并共享处理器的执行资源。</li><li><strong>核心数、线程数</strong> : 目前主流CPU都是多核的。增加核心数目就是为了增加线程数,因为操作系统是通过线程来执行任务的,一般情况下它们是1:1对应关系,也就是说四核CPU一般拥有四个线程。但 Intel引入超线程技术后,使核心数与线程数形成1:2的关系<br><img src="E266F53177EB4EE99899B8EB56BFADB4" alt="image"></li></ul></blockquote><h5 id="时间片轮转机制"><a href="#时间片轮转机制" class="headerlink" title="时间片轮转机制"></a><h4 id="1.3">时间片轮转机制</h5></h5><blockquote><ul><li>我们平时在开发的时候，感觉并没有受cpu核心数的限制，想启动线程就启动线程，哪怕是在单核CPU上，为什么？这是因为操作系统提供了一种CPU时间片轮转机制。</li><li>时间片轮转调度是一种最古老、最简单、最公平且使用最广的算法,又称RR调度。每个进程被分配一个时间段,称作它的时间片,即该进程允许运行的时间。</li><li>百度百科对CPU时间片轮转机制原理解释如下:<br>如果在时间片结束时进程还在运行,则CPU将被剥夺并分配给另一个进程。如果进程在时间片结束前阻塞或结来,则CPU当即进行切换。调度程序所要做的就是维护一张就绪进程列表,当进程用完它的时间片后,它被移到队列的末尾</li><li>时间片轮转调度中唯一有趣的一点是时间片的长度。从一个进程切换到另一个进程是需要定时间的,包括保存和装入寄存器值及内存映像,更新各种表格和队列等。假如进程切( processwitch),有时称为上下文切换( context switch),需要5ms,再假设时间片设为20ms,则在做完20ms有用的工作之后,CPU将花费5ms来进行进程切换。CPU时间的20%被浪费在了管理开销上了。</li><li>为了提高CPU效率,我们可以将时间片设为5000ms。这时浪费的时间只有0.1%。但考虑到在一个分时系统中,如果有10个交互用户几乎同时按下回车键,将发生什么情况?假设所有其他进程都用足它们的时间片的话,最后一个不幸的进程不得不等待5s才获得运行机会。多数用户无法忍受一条简短命令要5才能做出响应,同样的问题在一台支持多道程序的个人计算机上也会发</li><li>结论可以归结如下:时间片设得太短会导致过多的进程切换,降低了CPU效率:而设得太长又可能引起对短的交互请求的响应变差。将时间片设为100ms通常是一个比较合理的折衷。</li><li>在CPU死机的情况下,其实大家不难发现当运行一个程序的时候把CPU给弄到了100%再不重启电脑的情况下,其实我们还是有机会把它KⅢ掉的,我想也正是因为这种机制的缘故。</li></ul></blockquote><h5 id="澄清并行和并发"><a href="#澄清并行和并发" class="headerlink" title="澄清并行和并发"></a><h4 id="1.4">澄清并行和并发</h5></h5><blockquote><ul><li>我们举个例子,如果有条高速公路A上面并排有8条车道,那么最大的并行车辆就是8辆此条高速公路A同时并排行走的车辆小于等于8辆的时候,车辆就可以并行运行。CPU也是这个原理,一个CPU相当于一个高速公路A,核心数或者线程数就相当于并排可以通行的车道;而多个CPU就相当于并排有多条高速公路,而每个高速公路并排有多个车道。</li><li>当谈论并发的时候一定要加个单位时间,也就是说单位时间内并发量是多少?离开了单位时间其实是没有意义的。</li><li>俗话说,一心不能二用,这对计算机也一样,原则上一个CPU只能分配给一个进程,以便运行这个进程。我们通常使用的计算机中只有一个CPU,也就是说只有一颗心,要让它一心多用同时运行多个进程,就必须使用并发技术。实现并发技术相当复杂,最容易理解的是“时间片轮转进程调度算法”。</li><li>综合来说：</li><li><strong>并发</strong>:指应用能够交替执行不同的任务,比如单CPU核心下执行多线程并非是同时执行多个任务,如果你开两个线程执行,就是在你几乎不可能察觉到的速度不断去切换这两个任务,已达到”同时执行效果”,其实并不是的,只是计算机的速度太快,我们无法察觉到而已.</li><li><strong>并行</strong>:指应用能够同时执行不同的任务,例:吃饭的时候可以边吃饭边打电话,这两件事情可以同时执行</li><li>两者区别:一个是交替执行,一个是同时执行:</li></ul></blockquote><p><img src="B257CDED270B41E790300A2A9B4CFAA0" alt="image"></p><h5 id="高并发编程的意义"><a href="#高并发编程的意义" class="headerlink" title="高并发编程的意义"></a><h4 id="1.5">高并发编程的意义</h5></h5><blockquote><ul><li>由于多核多线程的CPU的诞生,多线程、高并发的编程越来越受重视和关注。多线程可以给程序带来如下好处。</li></ul></blockquote><h5 id="1-充分利用CPU的资源"><a href="#1-充分利用CPU的资源" class="headerlink" title="1,充分利用CPU的资源"></a>1,充分利用CPU的资源</h5><blockquote><ul><li>从上面的CPU的介绍,可以看的出来,现在市面上没有CPU的内核不使用多线程并发机制的,特别是服务器还不止一个CPU,如果还是使用单线程的技术做思路,明显就out了。因为程序的基本调度单元是线程,并且一个线程也只能在一个CPU的一个核的一个线程跑,如果你是个i3的CPU的话,最差也是双核心4线程的运算能力:如果是一个线程的程序的话,那是要浪费3/4的CPU性能:如果设计一个多线程的程序的话,那它就可以同时在多个CPU的多个核的多个线程上跑,可以充分地利用CPU,减少CPU的空闲时间,发挥它的运算能力,提高并发量。</li><li>就像我们平时坐地铁一样,很多人坐长线地铁的时候都在认真看书,而不是为了坐地铁而坐地铁,到家了再去看书,这样你的时间就相当于有了两倍。这就是为什么有些人时间很充裕,而有些人老是说没时间的一个原因,工作也是这样,有的时候可以并发地去做几件事情,充分利用我们的时间,CPU也是一样,也要充分利用。</li></ul></blockquote><h5 id="2-加快响应用户的时间"><a href="#2-加快响应用户的时间" class="headerlink" title="2,加快响应用户的时间"></a>2,加快响应用户的时间</h5><blockquote><ul><li>比如我们经常用的迅雷下载,都喜欢多开几个线程去下载,谁都不愿意用一个线程去下载,为什么呢?答案很简单,就是多个线程下载快啊。</li><li>我们在做程序开发的时候更应该如此,特别是我们做互联网项目,网页的响应时间若提升1s,如果流量大的话,就能增加不少转换量。做过高性能web前端调优的都知道,要将静态资源地址用两三个子域名去加载,为什么?因为每多一个子域名,浏览器在加载你的页面的时候就会多开几个线程去加载你的页面资源,提升网站的响应速度。多线程,高并发真的是无处不在。</li></ul></blockquote><h5 id="3-可以使你的代码模块化-异步化-简单化"><a href="#3-可以使你的代码模块化-异步化-简单化" class="headerlink" title="3,可以使你的代码模块化,异步化,简单化"></a>3,可以使你的代码模块化,异步化,简单化</h5><blockquote><ul><li>例如我们实现电商系统，下订单和给用户发送短信、邮件就可以进行拆分，将给用户发送短信、邮件这两个步骤独立为单独的模块，并交给其他线程去执行。这样既增加了异步的操作，提升了系统性能，又使程序模块化,清晰化和简单化。</li><li>多线程应用开发的好处还有很多,大家在日后的代码编写过程中可以慢慢体会它的魅力。</li></ul></blockquote><h5 id="多线程程序需要注意事项"><a href="#多线程程序需要注意事项" class="headerlink" title="多线程程序需要注意事项"></a><h4 id="1.6">多线程程序需要注意事项</h5></h5><h5 id="1-线程之间的安全性"><a href="#1-线程之间的安全性" class="headerlink" title="1,线程之间的安全性"></a>1,线程之间的安全性</h5><blockquote><ul><li>从前面的章节中我们都知道,在同一个进程里面的多线程是资源共享的,也就是都可以访问同一个内存地址当中的一个变量。例如:若每个线程中对全局变量、静态变量只有读操作,而无写操作,一般来说,这个全局变量是线程安全的:若有多个线程同时执行写操作,一般都需要考虑线程同步,否则就可能影响线程安全。</li></ul></blockquote><h5 id="2-线程之间的死锁"><a href="#2-线程之间的死锁" class="headerlink" title="2,线程之间的死锁"></a>2,线程之间的死锁</h5><blockquote><ul><li>为了解决线程之间的安全性引入了Java的锁机制,而一不小心就会产生Java线程死锁的多线程问题,因为不同的线程都在等待那些根本不可能被释放的锁,从而导致所有的工作都无法完成。假设有两个线程,分别代表两个饥饿的人,他们必须共享刀叉并轮流吃饭。他们都需要获得两个锁:共享刀和共享叉的锁。</li><li>假如线程A获得了刀,而线程B获得了叉。线程A就会进入阻塞状态来等待获得叉,而线程B则阻塞来等待线程A所拥有的刀。这只是人为设计的例子,但尽管在运行时很难探测到,这类情况却时常发生</li></ul></blockquote><h5 id="3-线程太多了会将服务器资源耗尽形成死机当机"><a href="#3-线程太多了会将服务器资源耗尽形成死机当机" class="headerlink" title="3,线程太多了会将服务器资源耗尽形成死机当机"></a>3,线程太多了会将服务器资源耗尽形成死机当机</h5><blockquote><ul><li>线程数太多有可能造成系统创建大量线程而导致消耗完系统内存以及CPU的“过渡切换”,造成系统的死机,那么我们该如何解决这类问题呢?</li><li>某些系统资源是有限的,如文件描述符。多线程程序可能耗尽资源,因为每个线程都可能希望有一个这样的资源。如果线程数相当大,或者某个资源的侯选线程数远远超过了可用的资源数则最好使用资源池。一个最好的示例是数据库连接池。只要线程需要使用一个数据库连接,它就从池中取出一个,使用以后再将它返回池中。资源池也称为资源库。</li><li>多线程应用开发的注意事项很多,希望大家在日后的工作中可以慢慢体会它的危险所在。</li></ul></blockquote><h3 id="二、认识Java里的线程"><a href="#二、认识Java里的线程" class="headerlink" title="二、认识Java里的线程"></a><h3 id="2">二、认识Java里的线程</h3></h3><h5 id="Java程序天生就是多线程的"><a href="#Java程序天生就是多线程的" class="headerlink" title="Java程序天生就是多线程的"></a><h4 id="2.1">Java程序天生就是多线程的</h5></h5><blockquote><ul><li>一个Java程序从main()方法开始执行，然后按照既定的代码逻辑执行，看似没有其他线程参与，但实际上Java程序天生就是多线程程序，因为执行main()方法的是一个名称为main的线程。</li></ul><ol><li>Monitor Ctrl-Break //监控Ctrl-Break中断信号的</li><li>Attach Listener //内存dump，线程dump，类信息统计，获取系统属性等</li><li>Signal Dispatcher  // 分发处理发送给JVM信号的线程</li><li>Finalizer  // 调用对象finalize方法的线程</li><li>Reference Handler//清除Reference的线程</li><li>main //main线程，用户程序入口</li></ol></blockquote><h5 id="线程的启动与中止"><a href="#线程的启动与中止" class="headerlink" title="线程的启动与中止"></a><h4 id="2.2">线程的启动与中止</h5></h5><h5 id="1-启动"><a href="#1-启动" class="headerlink" title="1, 启动"></a>1, 启动</h5><blockquote><ul><li>启动线程的方式有：</li><li>1、X extends Thread;，然后X.start</li><li>2、X implements  Runnable；然后交给Thread运行</li><li>参见代码：cn.enjoyedu.ch1.base.NewThread</li><li>Thread和Runnable的区别</li><li>Thread才是Java里对线程的唯一抽象，Runnable只是对任务（业务逻辑）的抽象。Thread可以接受任意一个Runnable的实例并执行。</li></ul></blockquote><h5 id="2-中止"><a href="#2-中止" class="headerlink" title="2, 中止"></a>2, 中止</h5><blockquote><ul><li>线程自然终止, 要么是run执行完成了，要么是抛出了一个未处理的异常导致线程提前结束。</li></ul></blockquote><h5 id="3-stop"><a href="#3-stop" class="headerlink" title="3, stop"></a>3, stop</h5><blockquote><ul><li>暂停、恢复和停止操作对应在线程Thread的API就是suspend()、resume()和stop()。但是这些API是过期的，也就是不建议使用的。不建议使用的原因主要有：以suspend()方法为例，在调用后，线程不会释放已经占有的资源（比如锁），而是占有着资源进入睡眠状态，这样容易引发死锁问题。同样，stop()方法在终结一个线程时不会保证线程的资源正常释放，通常是没有给予线程完成资源释放工作的机会，因此会导致程序可能工作在不确定状态下。正因为suspend()、resume()和stop()方法带来的副作用，这些方法才被标注为不建议使用的过期方法。</li></ul></blockquote><h5 id="4-中断"><a href="#4-中断" class="headerlink" title="4, 中断"></a>4, 中断</h5><blockquote><ul><li>安全的中止则是其他线程通过调用某个线程A的interrupt()方法对其进行中断操作, 中断好比其他线程对该线程打了个招呼，“A，你要中断了”，不代表线程A会立即停止自己的工作，同样的A线程完全可以不理会这种中断请求。因为java里的线程是协作式的，不是抢占式的。线程通过检查自身的中断标志位是否被置为true来进行响应，</li><li>线程通过方法isInterrupted()来进行判断是否被中断，也可以调用静态方法Thread.interrupted()来进行判断当前线程是否被中断，不过Thread.interrupted()会同时将中断标识位改写为false。</li><li>如果一个线程处于了阻塞状态（如线程调用了thread.sleep、thread.join、thread.wait等），则在线程在检查中断标示时如果发现中断标示为true，则会在这些阻塞方法调用处抛出InterruptedException异常，并且在抛出异常后会立即将线程的中断标示位清除，即重新设置为false。</li><li>不建议自定义一个取消标志位来中止线程的运行。因为run方法里有阻塞调用时会无法很快检测到取消标志，线程必须从阻塞调用返回后，才会检查这个取消标志。这种情况下，使用中断会更好，因为，</li><li>一、一般的阻塞方法，如sleep等本身就支持中断的检查，</li><li>二、检查中断位的状态和检查取消标志位没什么区别，用中断位的状态还可以避免声明取消标志位，减少资源的消耗。</li><li>注意：处于死锁状态的线程无法被中断</li></ul></blockquote><h3 id="三、对Java里的线程再多一点点认识"><a href="#三、对Java里的线程再多一点点认识" class="headerlink" title="三、对Java里的线程再多一点点认识"></a><h3 id="3">三、对Java里的线程再多一点点认识</h3></h3><h5 id="深入理解run-和start"><a href="#深入理解run-和start" class="headerlink" title="深入理解run()和start()"></a><h4 id="3.1">深入理解run()和start()</h4></h5><blockquote><ul><li>Thread类是Java里对线程概念的抽象，可以这样理解：我们通过new Thread()其实只是new出一个Thread的实例，还没有操作系统中真正的线程挂起钩来。只有执行了start()方法后，才实现了真正意义上的启动线程。</li><li>start()方法让一个线程进入就绪队列等待分配cpu，分到cpu后才调用实现的run()方法，start()方法不能重复调用，如果重复调用会抛出异常。</li><li>而run方法是业务逻辑实现的地方，本质上和任意一个类的任意一个成员方法并没有任何区别，可以重复执行，也可以被单独调用。</li></ul></blockquote><h5 id="其他的线程相关方法"><a href="#其他的线程相关方法" class="headerlink" title="其他的线程相关方法"></a><h4 id="3.2">其他的线程相关方法</h4></h5><blockquote><ul><li>yield()方法：使当前线程让出CPU占有权，但让出的时间是不可设定的。也不会释放锁资源。注意：并不是每个线程都需要这个锁的，而且执行yield( )的线程不一定就会持有锁，我们完全可以在释放锁后再调用yield方法。</li><li>所有执行yield()的线程有可能在进入到就绪状态后会被操作系统再次选中马上又被执行。</li><li>wait()/notify()/notifyAll()：后面会单独讲述</li></ul></blockquote><h5 id="join方法"><a href="#join方法" class="headerlink" title="join方法"></a><h4 id="3.3">join方法</h4></h5><blockquote><ul><li>把指定的线程加入到当前线程，可以将两个交替执行的线程合并为顺序执行。比如在线程B中调用了线程A的Join()方法，直到线程A执行完毕后，才会继续执行线程B。(此处为常见面试考点)</li></ul></blockquote><h5 id="线程的优先级"><a href="#线程的优先级" class="headerlink" title="线程的优先级"></a><h4 id="3.4">线程的优先级</h4></h5><blockquote><ul><li>在Java线程中，通过一个整型成员变量priority来控制优先级，优先级的范围从1~10，在线程构建的时候可以通过setPriority(int)方法来修改优先级，默认优先级是5，优先级高的线程分配时间片的数量要多于优先级低的线程。</li><li>设置线程优先级时，针对频繁阻塞（休眠或者I/O操作）的线程需要设置较高优先级，而偏重计算（需要较多CPU时间或者偏运算）的线程则设置较低的优先级，确保处理器不会被独占。在不同的JVM以及操作系统上，线程规划会存在差异，有些操作系统甚至会忽略对线程优先级的设定。</li></ul></blockquote><h5 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a><h4 id="3.5">守护线程</h4></h5><blockquote><ul><li>Daemon（守护）线程是一种支持型线程，因为它主要被用作程序中后台调度以及支持性工作。这意味着，当一个Java虚拟机中不存在非Daemon线程的时候，Java虚拟机将会退出。可以通过调用Thread.setDaemon(true)将线程设置为Daemon线程。我们一般用不上，比如垃圾回收线程就是Daemon线程。</li><li>Daemon线程被用作完成支持性工作，但是在Java虚拟机退出时Daemon线程中的finally块并不一定会执行。在构建Daemon线程时，不能依靠finally块中的内容来确保执行关闭或清理资源的逻辑。</li></ul></blockquote><h3 id="四、线程间的共享和协作"><a href="#四、线程间的共享和协作" class="headerlink" title="四、线程间的共享和协作"></a><h3 id="4">四、线程间的共享和协作</h3></h3><h5 id="线程间的共享"><a href="#线程间的共享" class="headerlink" title="线程间的共享"></a><h4 id="4.1">线程间的共享</h4></h5><h5 id="1-synchronized内置锁"><a href="#1-synchronized内置锁" class="headerlink" title="1,synchronized内置锁"></a>1,synchronized内置锁</h5><blockquote><ul><li>线程开始运行，拥有自己的栈空间，就如同一个脚本一样，按照既定的代码一步一步地执行，直到终止。但是，每个运行中的线程，如果仅仅是孤立地运行，那么没有一点儿价值，或者说价值很少，如果多个线程能够相互配合完成工作，包括数据之间的共享，协同处理事情。这将会带来巨大的价值。</li><li>Java支持多个线程同时访问一个对象或者对象的成员变量，关键字synchronized可以修饰方法或者以同步块的形式来进行使用，它主要确保多个线程在同一个时刻，只能有一个线程处于方法或者同步块中，它保证了线程对变量访问的可见性和排他性，又称为内置锁机制。</li><li>对象锁和类锁：</li><li>对象锁是用于对象实例方法，或者一个对象实例上的，类锁是用于类的静态方法或者一个类的class对象上的。我们知道，类的对象实例可以有很多个，但是每个类只有一个class对象，所以不同对象实例的对象锁是互不干扰的，但是每个类只有一个类锁。</li><li>但是有一点必须注意的是，其实类锁只是一个概念上的东西，并不是真实存在的，类锁其实锁的是每个类的对应的class对象。类锁和对象锁之间也是互不干扰的。</li><li>对象锁和类锁，以及锁static变量之间的运行情况，请参考包cn.enjoyedu.ch1.syn下的代码。</li></ul></blockquote><h5 id="2-错误的加锁和原因分析"><a href="#2-错误的加锁和原因分析" class="headerlink" title="2,错误的加锁和原因分析"></a>2,错误的加锁和原因分析</h5><blockquote><ul><li>参见代码cn.enjoyedu.ch1. syn.TestIntegerSyn</li><li>原因：虽然我们对i进行了加锁，但是<br><img src="7641B0A1DB764E6DA517CE601171BD71" alt="image"></li><li>但是当我们反编译这个类的class文件后，可以看到i++实际是，<br><img src="012D8CC9BCC6458BAA7BF734DBE74521" alt="image"><br><img src="51DAB8E8AD2B44BDB7A07933272F80AD" alt="image"></li><li>本质上是返回了一个新的Integer对象。也就是每个线程实际加锁的是不同的Integer对象。</li></ul></blockquote><h5 id="3-volatile，最轻量的同步机制"><a href="#3-volatile，最轻量的同步机制" class="headerlink" title="3,volatile，最轻量的同步机制"></a>3,volatile，最轻量的同步机制</h5><blockquote><ul><li>volatile保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。参见代码：cn.enjoyedu.ch1.vola. VolatileCase</li></ul></blockquote><p>-<img src="139E459E8EA44AB09256725C2D2D0A3C" alt="image"></p><blockquote><ul><li>不加volatile时，子线程无法感知主线程修改了ready的值，从而不会退出循环，而加了volatile后，子线程可以感知主线程修改了ready的值，迅速退出循环。<br>但是volatile不能保证数据在多个线程下同时写时的线程安全，参见代码：<br>cn.enjoyedu.ch1.vola. NotSafe<br>volatile最适用的场景：一个线程写，多个线程读。</li></ul></blockquote><h5 id="ThreadLocal辨析"><a href="#ThreadLocal辨析" class="headerlink" title="ThreadLocal辨析"></a><h4 id="4.2">ThreadLocal辨析</h4></h5><h5 id="1-与Synchonized的比较"><a href="#1-与Synchonized的比较" class="headerlink" title="1,与Synchonized的比较"></a>1,与Synchonized的比较</h5><blockquote><ul><li>ThreadLocal和Synchonized都用于解决多线程并发訪问。可是ThreadLocal与synchronized有本质的差别。synchronized是利用锁的机制，使变量或代码块在某一时该仅仅能被一个线程訪问。而ThreadLocal为每个线程都提供了变量的副本，使得每个线程在某一时间訪问到的并非同一个对象，这样就隔离了多个线程对数据的数据共享。</li><li>Spring的事务就借助了ThreadLocal类。Spring会从数据库连接池中获得一个connection，然会把connection放进ThreadLocal中，也就和线程绑定了，事务需要提交或者回滚，只要从ThreadLocal中拿到connection进行操作。为何Spring的事务要借助ThreadLocal类？</li><li>以JDBC为例，正常的事务代码可能如下：</li></ul></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dbc = new DataBaseConnection();//第1行</span><br><span class="line">Connection con = dbc.getConnection();//第2行</span><br><span class="line">con.setAutoCommit(false);// //第3行</span><br><span class="line">con.executeUpdate(...);//第4行</span><br><span class="line">con.executeUpdate(...);//第5行</span><br><span class="line">con.executeUpdate(...);//第6行</span><br><span class="line">con.commit();////第7行</span><br></pre></td></tr></table></figure><blockquote><ul><li>上述代码，可以分成三个部分:<br>事务准备阶段：第1～3行<br>业务处理阶段：第4～6行<br>事务提交阶段：第7行 </li><li>可以很明显的看到，不管我们开启事务还是执行具体的sql都需要一个具体的数据库连接。</li><li>现在我们开发应用一般都采用三层结构，如果我们控制事务的代码都放在DAO(DataAccessObject)对象中，在DAO对象的每个方法当中去打开事务和关闭事务，当Service对象在调用DAO时，如果只调用一个DAO，那我们这样实现则效果不错，但往往我们的Service会调用一系列的DAO对数据库进行多次操作，那么，这个时候我们就无法控制事务的边界了，因为实际应用当中，我们的Service调用的DAO的个数是不确定的，可根据需求而变化，而且还可能出现Service调用Service的情况。</li><li>如果不使用ThreadLocal，代码大概就会是这个样子：</li></ul></blockquote><p><img src="51AFE297A29A42D7ADDBE62E61FF9F11" alt="image">    <img src="C2E94688C9494E54B295DE0E2F2E5EA0" alt="image"></p><blockquote><ul><li>但是需要注意一个问题，如何让三个DAO使用同一个数据源连接呢？我们就必须为每个DAO传递同一个数据库连接，要么就是在DAO实例化的时候作为构造方法的参数传递，要么在每个DAO的实例方法中作为方法的参数传递。这两种方式无疑对我们的Spring框架或者开发人员来说都不合适。为了让这个数据库连接可以跨阶段传递，又不显示的进行参数传递，就必须使用别的办法。</li><li>Web容器中，每个完整的请求周期会由一个线程来处理。因此，如果我们能将一些参数绑定到线程的话，就可以实现在软件架构中跨层次的参数共享（是隐式的共享）。而JAVA中恰好提供了绑定的方法–使用ThreadLocal。</li><li>结合使用Spring里的IOC和AOP，就可以很好的解决这一点。</li><li>只要将一个数据库连接放入ThreadLocal中，当前线程执行时只要有使用数据库连接的地方就从ThreadLocal获得就行了。</li></ul></blockquote><h5 id="2-ThreadLocal的使用"><a href="#2-ThreadLocal的使用" class="headerlink" title="2,ThreadLocal的使用"></a>2,ThreadLocal的使用</h5><blockquote><ul><li>ThreadLocal类接口很简单，只有4个方法，我们先来了解一下：</li></ul></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void set(Object value)</span><br></pre></td></tr></table></figure><blockquote><ul><li>设置当前线程的线程局部变量的值。</li></ul></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public Object get()</span><br></pre></td></tr></table></figure><blockquote><ul><li>该方法返回当前线程所对应的线程局部变量。</li></ul></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public void remove()</span><br></pre></td></tr></table></figure><blockquote><ul><li>将当前线程局部变量的值删除，目的是为了减少内存的占用，该方法是JDK 5.0新增的方法。需要指出的是，当线程结束后，对应该线程的局部变量将自动被垃圾回收，所以显式调用该方法清除线程的局部变量并不是必须的操作，但它可以加快内存回收的速度。</li></ul></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protected Object initialValue()</span><br></pre></td></tr></table></figure><blockquote><ul><li>返回该线程局部变量的初始值，该方法是一个protected的方法，显然是为了让子类覆盖而设计的。这个方法是一个延迟调用方法，在线程第1次调用get()或set(Object)时才执行，并且仅执行1次。ThreadLocal中的缺省实现直接返回一个null。</li></ul></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public final static ThreadLocal&lt;String&gt; RESOURCE = new ThreadLocal&lt;String&gt;();</span><br></pre></td></tr></table></figure><blockquote><ul><li>RESOURCE代表一个能够存放String类型的ThreadLocal对象。此时不论什么一个线程能够并发访问这个变量，对它进行写入、读取操作，都是线程安全的。</li></ul></blockquote><h5 id="3-实现解析"><a href="#3-实现解析" class="headerlink" title="3,实现解析"></a>3,实现解析</h5><p><img src="8B8EF012A1E246A7B909642F1E286152" alt="image"></p><p><img src="735CCDB31AEE431682728A739A6ECC8F" alt="image"></p><p><img src="B91D0DFEE2CC4E589696ACAE901E4D40" alt="image"></p><p><img src="15187365622B4583BD91397605285A10" alt="image"></p><blockquote><ul><li>上面先取到当前线程，然后调用getMap方法获取对应的ThreadLocalMap，ThreadLocalMap是ThreadLocal的静态内部类，然后Thread类中有一个这样类型成员，所以getMap是直接返回Thread的成员。</li><li>看下ThreadLocal的内部类ThreadLocalMap源码：</li></ul></blockquote><p><img src="19571F7FADD54B28830466EDAC8054E9" alt="image"> </p><blockquote><ul><li>可以看到有个Entry内部静态类，它继承了WeakReference，总之它记录了两个信息，一个是ThreadLocal&lt;?&gt;类型，一个是Object类型的值。getEntry方法则是获取某个ThreadLocal对应的值，set方法就是更新或赋值相应的ThreadLocal对应的值。</li></ul></blockquote><p><img src="E2559C6F6D5B4F33A16710EB67AA0E9E" alt="image"></p><p><img src="A7D2A1414AB144A4A832881462F19357" alt="image"></p><blockquote><ul><li>回顾我们的get方法，其实就是拿到==每个线程独有的ThreadLocalMap==</li><li>然后再用ThreadLocal的当前实例，拿到Map中的相应的Entry，然后就可以拿到相应的值返回出去。当然，如果Map为空，还会先进行map的创建，初始化等工作。</li></ul></blockquote><h5 id="4-引发的内存泄漏分析"><a href="#4-引发的内存泄漏分析" class="headerlink" title="4,引发的内存泄漏分析"></a>4,引发的内存泄漏分析</h5><blockquote><ul><li>预备知识</li></ul></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object o = new Object();</span><br></pre></td></tr></table></figure><blockquote><ul><li>这个o，我们可以称之为对象引用，而new Object()我们可以称之为在内存中产生了一个对象实例。</li></ul></blockquote><p><img src="E2F0E85E699D42A8ABCBE5FF5CF43E64" alt="image"></p><blockquote><ul><li>当写下 o=null时，只是表示o不再指向堆中object的对象实例，不代表这个对象实例不存在了。</li><li><strong>强引用</strong> : 就是指在程序代码之中普遍存在的，类似“Object obj=new Object（）”这类的引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象实例。</li><li>软引用是用来描述一些还有用但并非必需的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象实例列进回收范围之中进行第二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常。在JDK 1.2之后，提供了SoftReference类来实现软引用。</li><li><strong>弱引用</strong> : 也是用来描述非必需对象的，但是它的强度比软引用更弱一些，被弱引用关联的对象实例只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象实例。在JDK 1.2之后，提供了WeakReference类来实现弱引用。</li><li><strong>虚引用</strong> :也称为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象实例是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象实例被收集器回收时收到一个系统通知。在JDK 1.2之后，提供了PhantomReference类来实现虚引用。</li></ul></blockquote><blockquote><ul><li>内存泄漏的现象</li><li>执行cn.enjoyedu.ch1.threadlocal下的ThreadLocalOOM，并将堆内存大小设置为-Xmx256m，</li><li>我们启用一个线程池，大小固定为5个线程</li></ul></blockquote><p><img src="F31AB97BF9B64F7AAA0652F5DED7FAEF" alt="image"></p><blockquote><ul><li>场景1，首先任务中不执行任何有意义的代码，当所有的任务提交执行完成后，可以看见，我们这个应用的内存占用基本上为25M左右</li></ul></blockquote><p><img src="51755A3350F54BC3AE1F529A4F7B1B5F" alt="image"></p><blockquote><ul><li>场景2，然后我们只简单的在每个任务中new出一个数组，执行完成后我们可以看见，内存占用基本和场景1同</li></ul></blockquote><p><img src="D778F22930B04AD4BC18BB042932D61B" alt="image"></p><blockquote><ul><li>场景3，当我们启用了ThreadLocal以后：</li></ul></blockquote><p><img src="64BAA7B6ED3749D6BFBE98A9CFE284AA" alt="image"></p><blockquote><p>执行完成后我们可以看见，内存占用变为了100多M<br>场景4，于是，我们加入一行代码，再执行，看看内存情况:</p></blockquote><p><img src="725A5C2B25564F5CAC2ED3FE75695F94" alt="image"></p><blockquote><ul><li>可以看见，内存占用基本和场景1同。</li><li>这就充分说明，场景3，当我们启用了ThreadLocal以后确实发生了内存泄漏。<br>分析</li><li>根据我们前面对ThreadLocal的分析，我们可以知道每个Thread 维护一个 ThreadLocalMap，这个映射表的 key 是 ThreadLocal实例本身，value 是真正需要存储的 Object，也就是说 ThreadLocal 本身并不存储值，它只是作为一个 key 来让线程从 ThreadLocalMap 获取 value。仔细观察ThreadLocalMap，这个map是使用 ThreadLocal 的弱引用作为 Key 的，弱引用的对象在 GC 时会被回收。</li><li>因此使用了ThreadLocal后，引用链如图所示</li></ul></blockquote><p><img src="7EDA4C1C0B2041C0A993D9A2DFA716BA" alt="image"></p><blockquote><ul><li>图中的虚线表示弱引用。</li><li>这样，当把threadlocal变量置为null以后，没有任何强引用指向threadlocal实例，所以threadlocal将会被gc回收。这样一来，ThreadLocalMap中就会出现key为null的Entry，就没有办法访问这些key为null的Entry的value，如果当前线程再迟迟不结束的话，这些key为null的Entry的value就会一直存在一条强引用链：Thread Ref -&gt; Thread -&gt; ThreaLocalMap -&gt; Entry -&gt; value，而这块value永远不会被访问到了，所以存在着内存泄露。</li><li>只有当前thread结束以后，current thread就不会存在栈中，强引用断开，Current Thread、Map - - - value将全部被GC回收。最好的做法是不在需要使用ThreadLocal变量后，都调用它的remove()方法，清除数据。<br>所以回到我们前面的实验场景，场景3中，虽然线程池里面的任务执行完毕了，但是线程池里面的5个线程会一直存在直到JVM退出，我们set了线程的localVariable变量后没有调用localVariable.remove()方法，导致线程池里面的5个线程的threadLocals变量里面的new LocalVariable()实例没有被释放。</li><li>其实考察ThreadLocal的实现，我们可以看见，无论是get()、set()在某些时候，调用了expungeStaleEntry方法用来清除Entry中Key为null的Value，但是这是不及时的，也不是每次都会执行的，所以一些情况下还是会发生内存泄露。只有remove()方法中显式调用了expungeStaleEntry方法。</li><li>从表面上看内存泄漏的根源在于使用了弱引用，但是另一个问题也同样值得思考：为什么使用弱引用而不是强引用？</li><li>下面我们分两种情况讨论：</li><li>key 使用强引用：对ThreadLocal对象实例的引用被置为null了，但是ThreadLocalMap还持有这个ThreadLocal对象实例的强引用，如果没有手动删除，ThreadLocal的对象实例不会被回收，导致Entry内存泄漏。</li><li>key 使用弱引用：对ThreadLocal对象实例的引用被被置为null了，由于ThreadLocalMap持有ThreadLocal的弱引用，即使没有手动删除，ThreadLocal的对象实例也会被回收。value在下一次ThreadLocalMap调用set，get，remove都有机会被回收。</li><li>比较两种情况，我们可以发现：由于ThreadLocalMap的生命周期跟Thread一样长，如果都没有手动删除对应key，都会导致内存泄漏，但是使用弱引用可以多一层保障。</li><li>因此，ThreadLocal内存泄漏的根源是：由于ThreadLocalMap的生命周期跟Thread一样长，如果没有手动删除对应key就会导致内存泄漏，而不是因为弱引用。</li></ul></blockquote><ul><li><strong>总结</strong></li><li>JVM利用设置ThreadLocalMap的Key为弱引用，来避免内存泄露。</li><li>JVM利用调用remove、get、set方法的时候，回收弱引用。</li><li>当ThreadLocal存储很多Key为null的Entry的时候，而不再去调用remove、get、set方法，那么将导致内存泄漏。<br>使用线程池+ ThreadLocal时要小心，因为这种情况下，线程是一直在不断的重复运行的，从而也就造成了value可能造成累积的情况。</li></ul><h5 id="5-错误使用ThreadLocal导致线程不安全"><a href="#5-错误使用ThreadLocal导致线程不安全" class="headerlink" title="5,错误使用ThreadLocal导致线程不安全"></a>5,错误使用ThreadLocal导致线程不安全</h5><blockquote><ul><li>参见代码cn.enjoyedu.ch1.threadlocal. ThreadLocalUnsafe<br>运行后的结果为</li></ul></blockquote><p><img src="6639F42C5C374AF8AE73E8769F09108F" alt="image"></p><blockquote><ul><li>如果我们加入SleepTools.ms(2);会看的更明显</li></ul></blockquote><p><img src="4F4F02914D2A4986A7A07A06BB0327A1" alt="image"></p><blockquote><ul><li>为什么每个线程都输出5？难道他们没有独自保存自己的Number副本吗？为什么其他线程还是能够修改这个值？仔细考察ThreadLocal和Thead的代码，我们发现ThreadLocalMap中保存的其实是对象的一个引用，这样的话，当有其他线程对这个引用指向的对象实例做修改时，其实也同时影响了所有的线程持有的对象引用所指向的同一个对象实例。这也就是为什么上面的程序为什么会输出一样的结果：5个线程中保存的是同一Number对象的引用，在线程睡眠的时候，其他线程将num变量进行了修改，而修改的对象Number的实例是同一份，因此它们最终输出的结果是相同的。</li><li>而上面的程序要正常的工作，应该的用法是让每个线程中的ThreadLocal都应该持有一个新的Number对象。</li></ul></blockquote><h5 id="线程间的协作"><a href="#线程间的协作" class="headerlink" title="线程间的协作"></a><h4 id="4.3">线程间的协作</h4></h5><blockquote><ul><li>线程之间相互配合，完成某项工作，比如：一个线程修改了一个对象的值，而另一个线程感知到了变化，然后进行相应的操作，整个过程开始于一个线程，而最终执行又是另一个线程。前者是生产者，后者就是消费者，这种模式隔离了“做什么”（what）和“怎么做”（How），简单的办法是让消费者线程不断地循环检查变量是否符合预期在while循环中设置不满足的条件，如果条件满足则退出while循环，从而完成消费者的工作。却存在如下问题：</li><li>1）    难以确保及时性。</li><li>2）难以降低开销。如果降低睡眠的时间，比如休眠1毫秒，这样消费者能更加迅速地发现条件变化，但是却可能消耗更多的处理器资源，造成了无端的浪费。</li><li>等待/通知机制 : 是指一个线程A调用了对象O的wait()方法进入等待状态，而另一个线程B调用了对象O的notify()或者notifyAll()方法，线程A收到通知后从对象O的wait()方法返回，进而执行后续操作。上述两个线程通过对象O来完成交互，而对象上的wait()和notify/notifyAll()的关系就如同开关信号一样，用来完成等待方和通知方之间的交互工作。</li><li>notify()：<br>通知一个在对象上等待的线程,使其从wait方法返回,而返回的前提是该线程获取到了对象的锁，没有获得锁的线程重新进入WAITING状态。</li><li>notifyAll()：<br>通知所有等待在该对象上的线程</li><li>wait() :<br>调用该方法的线程进入 WAITING状态,只有等待另外线程的通知或被中断才会返回.需要注意,调用wait()方法后,会释放对象的锁</li><li>wait(long) :<br>超时等待一段时间,这里的参数时间是毫秒,也就是等待长达n毫秒,如果没有通知就超时返回</li><li>wait (long,int) :<br>对于超时时间更细粒度的控制,可以达到纳秒</li></ul><ul><li><p>等待和通知的标准范式</p></li><li><p>等待方遵循如下原则。</p></li><li><p>1）获取对象的锁。</p></li><li><p>2）如果条件不满足，那么调用对象的wait()方法，被通知后仍要检查条件。</p></li><li><p>3）条件满足则执行对应的逻辑。</p></li></ul></blockquote><p><img src="17725CAED2CA47A0ADF2E23BD6ECF0EF" alt="image"></p><blockquote><ul><li>通知方遵循如下原则。</li></ul><ol><li>获得对象的锁。</li><li>改变条件。</li><li>通知所有等待在对象上的线程。</li></ol></blockquote><p><img src="624BD90B419C4E76B23DDD312954CFDF" alt="image"></p><blockquote><ul><li>在调用wait（）、notify()系列方法之前，线程必须要获得该对象的对象级别锁，即只能在同步方法或同步块中调用wait（）方法、notify()系列方法，进入wait（）方法后，当前线程释放锁，在从wait（）返回前，线程与其他线程竞争重新获得锁， 执行notify()系列方法的线程退出调用了notifyAll的synchronized代码块的时候后，他们就会去竞争。如果其中一个线程获得了该对象锁，它就会继续往下执行，在它退出synchronized代码块，释放锁后，其他的已经被唤醒的线程将会继续竞争获取该锁，一直进行下去，直到所有被唤醒的线程都执行完毕。</li><li>notify和notifyAll应该用谁</li><li>尽可能用notifyall()，谨慎使用notify()，因为notify()只会唤醒一个线程，我们无法确保被唤醒的这个线程一定就是我们需要唤醒的线程，具体表现参见代码:包cn.enjoyedu.ch1.wn 下</li><li>等待超时模式实现一个连接池</li><li>调用场景：调用一个方法时等待一段时间（一般来说是给定一个时间段），如果该方法能够在给定的时间段之内得到结果，那么将结果立刻返回，反之，超时返回默认结果。</li><li>假设等待时间段是T，那么可以推断出在当前时间now+T之后就会超时<br>等待持续时间：REMAINING=T。</li><li>超时时间：FUTURE=now+T。</li></ul></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 对当前对象加锁</span><br><span class="line">public synchronized Object get(long mills) throws InterruptedException &#123;</span><br><span class="line">long  future = System.currentTimeMillis() + mills;</span><br><span class="line">long  remaining = mills;</span><br><span class="line">// 当超时大于0并且result返回值不满足要求</span><br><span class="line">while ((result == null) &amp;&amp; remaining &gt; 0) &#123;</span><br><span class="line">wait(remaining);</span><br><span class="line">remaining = future - System.currentTimeMillis();</span><br><span class="line">&#125;</span><br><span class="line">return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li>具体实现参见：包下cn.enjoyedu.ch1.pool的代码</li><li>客户端获取连接的过程被设定为等待超时的模式，也就是在1000毫秒内如果无法获取到可用连接，将会返回给客户端一个null。设定连接池的大小为10个，然后通过调节客户端的线程数来模拟无法获取连接的场景。</li><li>它通过构造函数初始化连接的最大上限，通过一个双向队列来维护连接，调用方需要先调用fetchConnection(long)方法来指定在多少毫秒内超时获取连接，当连接使用完成后，需要调用releaseConnection(Connection)方法将连接放回线程池</li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;线程基础、线程之间的共享和协作&quot;&gt;&lt;a href=&quot;#线程基础、线程之间的共享和协作&quot; class=&quot;headerlink&quot; title=&quot;线程基础、线程之间的共享和协作&quot;&gt;&lt;/a&gt;线程基础、线程之间的共享和协作&lt;/h1&gt;&lt;!-- GFM-TOC --&gt;
&lt;ul&gt;
      
    
    </summary>
    
    
      <category term="java基础" scheme="https://hicker000.github.io/categories/java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="高并发" scheme="https://hicker000.github.io/tags/%E9%AB%98%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
</feed>
